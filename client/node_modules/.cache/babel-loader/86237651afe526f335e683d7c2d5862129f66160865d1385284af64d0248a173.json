{"ast":null,"code":"import { upperFirst, capitalize, last, pick, compose, evolve, mapValues, matchPercent, isNil, get, castArray, omit, asyncCompose } from '@react-pdf/fns';\nimport * as P from '@react-pdf/primitives';\nimport { TextInstance } from '@react-pdf/primitives';\nimport stylesheet, { transformColor, processTransform, flatten } from '@react-pdf/stylesheet';\nimport layoutEngine, { bidi, linebreaker, justification, textDecoration, scriptItemizer, wordHyphenation } from '@react-pdf/textkit';\nimport { PDFFont } from '@react-pdf/pdfkit';\nimport * as Yoga from 'yoga-layout/load';\nimport { loadYoga as loadYoga$1 } from 'yoga-layout/load';\nimport emojiRegex from 'emoji-regex';\nimport resolveImage from '@react-pdf/image';\n\n/**\n * Create attributed string from text fragments\n *\n * @param {Object[]} fragments fragments\n * @returns {Object} attributed string\n */\nconst fromFragments = fragments => {\n  let offset = 0;\n  let string = '';\n  const runs = [];\n  fragments.forEach(fragment => {\n    string += fragment.string;\n    runs.push({\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string,\n    runs\n  };\n};\n\n/**\n * Apply transformation to text string\n *\n * @param {string} text\n * @param {string} transformation type\n * @returns {string} transformed text\n */\nconst transformText = (text, transformation) => {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n    case 'lowercase':\n      return text.toLowerCase();\n    case 'capitalize':\n      return capitalize(text);\n    case 'upperfirst':\n      return upperFirst(text);\n    default:\n      return text;\n  }\n};\n\n/* eslint-disable class-methods-use-this */\n\nclass StandardFont {\n  constructor(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n  encode(str) {\n    return this.src.encode(str);\n  }\n  layout(str) {\n    const [encoded, positions] = this.encode(str);\n    return {\n      positions,\n      stringIndices: positions.map((_, i) => i),\n      glyphs: encoded.map((g, i) => {\n        const glyph = this.getGlyph(parseInt(g, 16));\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      })\n    };\n  }\n  glyphForCodePoint(codePoint) {\n    const glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  }\n  getGlyph(id) {\n    return {\n      id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id)\n    };\n  }\n  hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  }\n\n  // Based on empirical observation\n  get ascent() {\n    return 900;\n  }\n\n  // Based on empirical observation\n  get capHeight() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n      case 'Times-BoldItalic':\n        return 650;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n      case 'Courier-BoldOblique':\n        return 550;\n      default:\n        return 690;\n    }\n  }\n\n  // Based on empirical observation\n  get xHeight() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n      case 'Times-BoldItalic':\n        return 440;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n      case 'Courier-BoldOblique':\n        return 390;\n      default:\n        return 490;\n    }\n  }\n\n  // Based on empirical observation\n  get descent() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n      case 'Times-BoldItalic':\n        return -220;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n      case 'Courier-BoldOblique':\n        return -230;\n      default:\n        return -200;\n    }\n  }\n  get lineGap() {\n    return 0;\n  }\n  get unitsPerEm() {\n    return 1000;\n  }\n}\nconst fontCache = {};\nconst IGNORED_CODE_POINTS = [173];\nconst getFontSize = node => node.attributes.fontSize || 12;\nconst getOrCreateFont = name => {\n  if (fontCache[name]) return fontCache[name];\n  const font = new StandardFont(name);\n  fontCache[name] = font;\n  return font;\n};\nconst getFallbackFont = () => getOrCreateFont('Helvetica');\nconst pickFontFromFontStack = (codePoint, fontStack, lastFont) => {\n  const fontStackWithFallback = [...fontStack, lastFont, getFallbackFont()];\n  for (let i = 0; i < fontStackWithFallback.length; i += 1) {\n    const font = fontStackWithFallback[i];\n    if (!IGNORED_CODE_POINTS.includes(codePoint) && font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return font;\n    }\n  }\n  return getFallbackFont();\n};\nconst fontSubstitution = () => _ref => {\n  let {\n    string,\n    runs\n  } = _ref;\n  let lastFont = null;\n  let lastFontSize = null;\n  let lastIndex = 0;\n  let index = 0;\n  const res = [];\n  for (let i = 0; i < runs.length; i += 1) {\n    const run = runs[i];\n    const defaultFont = run.attributes.font.map(font => typeof font === 'string' ? getOrCreateFont(font) : font);\n    if (string.length === 0) {\n      res.push({\n        start: 0,\n        end: 0,\n        attributes: {\n          font: defaultFont\n        }\n      });\n      break;\n    }\n    const chars = string.slice(run.start, run.end);\n    for (let j = 0; j < chars.length; j += 1) {\n      const char = chars[j];\n      const codePoint = char.codePointAt();\n      // If the default font does not have a glyph and the fallback font does, we use it\n      const font = pickFontFromFontStack(codePoint, defaultFont, lastFont);\n      const fontSize = getFontSize(run);\n\n      // If anything that would impact res has changed, update it\n      if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: lastFont,\n              scale: lastFontSize / lastFont.unitsPerEm\n            }\n          });\n        }\n        lastFont = font;\n        lastFontSize = fontSize;\n        lastIndex = index;\n      }\n      index += char.length;\n    }\n  }\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(last(runs));\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: lastFont,\n        scale: fontSize / lastFont.unitsPerEm\n      }\n    });\n  }\n  return {\n    string,\n    runs: res\n  };\n};\nconst isTextInstance$4 = node => node.type === P.TextInstance;\nconst engines$1 = {\n  bidi,\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution\n};\nconst engine$1 = layoutEngine(engines$1);\nconst getFragments$1 = (fontStore, instance) => {\n  if (!instance) return [{\n    string: ''\n  }];\n  const fragments = [];\n  const {\n    fill = 'black',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    opacity\n  } = instance.props;\n  const _textDecoration = instance.props.textDecoration;\n  const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n  const font = fontFamilies.map(fontFamilyName => {\n    if (typeof fontFamilyName !== 'string') return fontFamilyName;\n    const opts = {\n      fontFamily: fontFamilyName,\n      fontWeight,\n      fontStyle\n    };\n    const obj = fontStore ? fontStore.getFont(opts) : null;\n    return obj ? obj.data : fontFamilyName;\n  });\n  const attributes = {\n    font,\n    opacity,\n    fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: _textDecoration === 'underline' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    underlineColor: textDecorationColor || fill,\n    strike: _textDecoration === 'line-through' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill\n  };\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n    if (isTextInstance$4(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments$1(child));\n    }\n  }\n  return fragments;\n};\nconst getAttributedString$1 = (fontStore, instance) => fromFragments(getFragments$1(fontStore, instance));\nconst AlmostInfinity = 999999999999;\nconst shrinkWhitespaceFactor = {\n  before: -0.5,\n  after: -0.5\n};\nconst layoutTspan = fontStore => node => {\n  var _node$props, _node$props2;\n  const attributedString = getAttributedString$1(fontStore, node);\n  const x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;\n  const y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;\n  const container = {\n    x,\n    y,\n    width: AlmostInfinity,\n    height: AlmostInfinity\n  };\n  const hyphenationCallback = node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null;\n  const layoutOptions = {\n    hyphenationCallback,\n    shrinkWhitespaceFactor\n  };\n  const lines = engine$1(attributedString, container, layoutOptions).flat();\n  return Object.assign({}, node, {\n    lines\n  });\n};\nconst layoutText$1 = (fontStore, node) => {\n  if (!node.children) return node;\n  const children = node.children.map(layoutTspan(fontStore));\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst isDefs = node => node.type === P.Defs;\nconst getDefs = node => {\n  const children = node.children || [];\n  const defs = children.find(isDefs) || {};\n  const values = defs.children || [];\n  return values.reduce((acc, value) => {\n    var _value$props;\n    const id = (_value$props = value.props) === null || _value$props === void 0 ? void 0 : _value$props.id;\n    if (id) acc[id] = value;\n    return acc;\n  }, {});\n};\nconst isNotDefs = node => node.type !== P.Defs;\nconst detachDefs = node => {\n  if (!node.children) return node;\n  const children = node.children.filter(isNotDefs);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\nconst replaceDef = (defs, value) => {\n  if (!value) return undefined;\n  if (!URL_REGEX.test(value)) return value;\n  const match = value.match(URL_REGEX);\n  return defs[match[1]];\n};\nconst parseNodeDefs = defs => node => {\n  var _node$props, _node$props2;\n  const fill = replaceDef(defs, (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fill);\n  const clipPath = replaceDef(defs, (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.clipPath);\n  const props = Object.assign({}, node.props, {\n    fill,\n    clipPath\n  });\n  const children = node.children ? node.children.map(parseNodeDefs(defs)) : undefined;\n  return Object.assign({}, node, {\n    props,\n    children\n  });\n};\nconst parseDefs = root => {\n  if (!root.children) return root;\n  const defs = getDefs(root);\n  const children = root.children.map(parseNodeDefs(defs));\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst replaceDefs = node => {\n  return detachDefs(parseDefs(node));\n};\nconst parseViewbox = value => {\n  if (!value) return null;\n  const values = value.split(/[,\\s]+/).map(parseFloat);\n  if (values.length !== 4) return null;\n  return {\n    minX: values[0],\n    minY: values[1],\n    maxX: values[2],\n    maxY: values[3]\n  };\n};\nconst getContainer$1 = node => {\n  const viewbox = parseViewbox(node.props.viewBox);\n  if (viewbox) {\n    return {\n      width: viewbox.maxX,\n      height: viewbox.maxY\n    };\n  }\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat(node.props.width),\n      height: parseFloat(node.props.height)\n    };\n  }\n  return {\n    width: 0,\n    height: 0\n  };\n};\nconst SVG_INHERITED_PROPS = ['x', 'y', 'clipPath', 'clipRule', 'opacity', 'fill', 'fillOpacity', 'fillRule', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeOpacity', 'strokeWidth', 'textAnchor', 'dominantBaseline', 'color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nconst getInheritProps = node => {\n  const props = node.props || {};\n  return pick(SVG_INHERITED_PROPS, props);\n};\nconst inheritProps = node => {\n  if (!node.children) return node;\n  const inheritedProps = getInheritProps(node);\n  const children = node.children.map(child => {\n    const props = Object.assign({}, inheritedProps, child.props || {});\n    const newChild = Object.assign({}, child, {\n      props\n    });\n    return inheritProps(newChild);\n  });\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst parseAspectRatio = value => {\n  const match = value.replace(/[\\s\\r\\t\\n]+/gm, ' ').replace(/^defer\\s/, '').split(' ');\n  const align = match[0] || 'xMidYMid';\n  const meetOrSlice = match[1] || 'meet';\n  return {\n    align,\n    meetOrSlice\n  };\n};\nconst STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray'];\nconst VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nconst HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\nconst isType$3 = type => node => node.type === type;\nconst isSvg$3 = isType$3(P.Svg);\nconst isText$5 = isType$3(P.Text);\nconst isTextInstance$3 = isType$3(P.TextInstance);\nconst transformPercent = container => props => mapValues(props, (value, key) => {\n  const match = matchPercent(value);\n  if (match && VERTICAL_PROPS.includes(key)) {\n    return match.percent * container.height;\n  }\n  if (match && HORIZONTAL_PROPS.includes(key)) {\n    return match.percent * container.width;\n  }\n  return value;\n});\nconst parsePercent = value => {\n  const match = matchPercent(value);\n  return match ? match.percent : parseFloat(value);\n};\nconst parseProps = container => node => {\n  let props = transformPercent(container)(node.props);\n  props = evolve({\n    x: parseFloat,\n    x1: parseFloat,\n    x2: parseFloat,\n    y: parseFloat,\n    y1: parseFloat,\n    y2: parseFloat,\n    r: parseFloat,\n    rx: parseFloat,\n    ry: parseFloat,\n    cx: parseFloat,\n    cy: parseFloat,\n    width: parseFloat,\n    height: parseFloat,\n    offset: parsePercent,\n    fill: transformColor,\n    opacity: parsePercent,\n    stroke: transformColor,\n    stopOpacity: parsePercent,\n    stopColor: transformColor,\n    transform: processTransform\n  }, props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst mergeStyles$1 = node => {\n  const style = node.style || {};\n  const props = Object.assign({}, style, node.props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst removeNoneValues = node => {\n  const removeNone = value => value === 'none' ? null : value;\n  const props = mapValues(node.props, removeNone);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst pickStyleProps = node => {\n  const props = node.props || {};\n  const styleProps = pick(STYLE_PROPS, props);\n  const style = Object.assign({}, styleProps, node.style || {});\n  return Object.assign({}, node, {\n    style\n  });\n};\nconst parseSvgProps = node => {\n  const props = evolve({\n    width: parseFloat,\n    height: parseFloat,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio\n  }, node.props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst wrapBetweenTspan = node => ({\n  type: P.Tspan,\n  props: {},\n  children: [node]\n});\nconst addMissingTspan = node => {\n  if (!isText$5(node)) return node;\n  if (!node.children) return node;\n  const resolveChild = child => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst parseText = fontStore => node => {\n  if (isText$5(node)) return layoutText$1(fontStore, node);\n  if (!node.children) return node;\n  const children = node.children.map(parseText(fontStore));\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst resolveSvgNode = container => compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);\nconst resolveChildren = container => node => {\n  if (!node.children) return node;\n  const resolveChild = compose(resolveChildren(container), resolveSvgNode(container));\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst resolveSvgRoot = (node, fontStore) => {\n  const container = getContainer$1(node);\n  return compose(replaceDefs, parseText(fontStore), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container))(node);\n};\n\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param {Object} node root node\n * @param {Object} fontStore font store\n * @returns {Object} root node\n */\nconst resolveSvg = (node, fontStore) => {\n  if (!node.children) return node;\n  const resolveChild = child => resolveSvg(child, fontStore);\n  const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore) : node;\n  const children = root.children.map(resolveChild);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\n/* eslint-disable import/prefer-default-export */\n\nlet instancePromise;\nconst loadYoga = async () => {\n  // Yoga WASM binaries must be asynchronously compiled and loaded\n  // to prevent Event emitter memory leak warnings, Yoga must be loaded only once\n  const instance = await (instancePromise ??= loadYoga$1());\n  const config = instance.Config.create();\n  config.setPointScaleFactor(0);\n  const node = {\n    create: () => instance.Node.createWithConfig(config)\n  };\n  return {\n    node\n  };\n};\nconst resolveYoga = async root => {\n  const yoga = await loadYoga();\n  return Object.assign({}, root, {\n    yoga\n  });\n};\nconst getZIndex = node => node.style.zIndex;\nconst shouldSort = node => node.type !== P.Document && node.type !== P.Svg;\nconst sortZIndex = (a, b) => {\n  const za = getZIndex(a);\n  const zb = getZIndex(b);\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n  return zb - za;\n};\n\n/**\n * Sort children by zIndex value\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolveZIndex = node => {\n  if (!node.children) return node;\n  const sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;\n  const children = sortedChildren.map(resolveZIndex);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\n/* eslint-disable no-cond-assign */\n\n// Caches emoji images data\nconst emojis = {};\nconst regex = emojiRegex();\nconst reflect = promise => function () {\n  return promise(...arguments).then(v => v, e => e);\n};\n\n// Returns a function to be able to mock resolveImage.\nconst makeFetchEmojiImage = () => reflect(resolveImage);\n\n/**\n * When an emoji as no variations, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst _removeVariationSelectors = x => x !== '️';\nconst getCodePoints = (string, withVariationSelectors) => Array.from(string).filter(withVariationSelectors ? () => true : _removeVariationSelectors).map(char => char.codePointAt(0).toString(16)).join('-');\nconst buildEmojiUrl = (emoji, source) => {\n  const {\n    url,\n    format,\n    builder,\n    withVariationSelectors\n  } = source;\n  if (typeof builder === 'function') {\n    return builder(getCodePoints(emoji, withVariationSelectors));\n  }\n  return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format}`;\n};\nconst fetchEmojis = (string, source) => {\n  if (!source || !source.url && !source.builder) return [];\n  const promises = [];\n  Array.from(string.matchAll(regex)).forEach(match => {\n    const emoji = match[0];\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      const emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      const fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(image => {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  });\n  return promises;\n};\nconst embedEmojis = fragments => {\n  const result = [];\n  for (let i = 0; i < fragments.length; i += 1) {\n    const fragment = fragments[i];\n    let lastIndex = 0;\n    Array.from(fragment.string.matchAll(regex)).forEach(match => {\n      const {\n        index\n      } = match;\n      const emoji = match[0];\n      const emojiSize = fragment.attributes.fontSize;\n      const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n\n      // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: {\n            ...fragment.attributes,\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          }\n        });\n      } else {\n        // If no emoji data, we try to use emojis in the font\n        result.push({\n          string: chunk,\n          attributes: fragment.attributes\n        });\n      }\n      lastIndex = index + emoji.length;\n    });\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Get image source\n *\n * @param {Object} node image node\n * @returns {string | Object} image src\n */\nconst getSource = node => {\n  var _node$props, _node$props2, _node$props3;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.src) || ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.source) || ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.href);\n};\n\n/**\n * Resolves `src` to `@react-pdf/image` interface.\n *\n * Also it handles factories and async sources.\n *\n * @param {string | Object | Function} src\n * @returns {Promise<Object>} resolved src\n */\nconst resolveSource = async src => {\n  const source = typeof src === 'function' ? await src() : await src;\n  return typeof source === 'string' ? {\n    uri: source\n  } : source;\n};\n\n/* eslint-disable no-param-reassign */\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param {Object} node\n */\nconst fetchImage = async node => {\n  const src = getSource(node);\n  const {\n    cache\n  } = node.props;\n  if (!src) {\n    console.warn(false, 'Image should receive either a \"src\" or \"source\" prop');\n    return;\n  }\n  try {\n    const source = await resolveSource(src);\n    if (!source) {\n      throw new Error(`Image's \"src\" or \"source\" prop returned ${source}`);\n    }\n    node.image = await resolveImage(source, {\n      cache\n    });\n    node.image.key = source.data ? source.data.toString() : source.uri;\n  } catch (e) {\n    node.image = {\n      width: 0,\n      height: 0,\n      key: null\n    };\n    console.warn(e.message);\n  }\n};\nconst isImage$2 = node => node.type === P.Image;\n\n/**\n * Get all asset promises that need to be resolved\n *\n * @param {Object} fontStore font store\n * @param {Object} node root node\n * @returns {Promise<void>[]} asset promises\n */\nconst fetchAssets = (fontStore, node) => {\n  var _node$children;\n  const promises = [];\n  const listToExplore = ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.slice(0)) || [];\n  const emojiSource = fontStore ? fontStore.getEmojiSource() : null;\n  while (listToExplore.length > 0) {\n    var _n$style;\n    const n = listToExplore.shift();\n    if (isImage$2(n)) {\n      promises.push(fetchImage(n));\n    }\n    if (fontStore && (_n$style = n.style) !== null && _n$style !== void 0 && _n$style.fontFamily) {\n      promises.push(fontStore.load(n.style));\n    }\n    if (typeof n === 'string') {\n      promises.push(...fetchEmojis(n, emojiSource));\n    }\n    if (typeof n.value === 'string') {\n      promises.push(...fetchEmojis(n.value, emojiSource));\n    }\n    if (n.children) {\n      n.children.forEach(childNode => {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n  return promises;\n};\n\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param {Object} node root node\n * @param {Object} fontStore font store\n * @returns {Promise<Object>} root node\n */\nconst resolveAssets = async (node, fontStore) => {\n  const promises = fetchAssets(fontStore, node);\n  await Promise.all(promises);\n  return node;\n};\nconst isLink$1 = node => node.type === P.Link;\nconst DEFAULT_LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline'\n};\n\n/**\n * Computes styles using stylesheet\n *\n * @param {Object} container\n * @param {Object} node document node\n * @returns {Object} computed styles\n */\nconst computeStyle = (container, node) => {\n  let baseStyle = node.style;\n  if (isLink$1(node)) {\n    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES, ...node.style] : [DEFAULT_LINK_STYLES, node.style];\n  }\n  return stylesheet(container, baseStyle);\n};\n\n/**\n * @typedef {Function} ResolveNodeStyles\n * @param {Object} node document node\n * @returns {Object} node (and subnodes) with resolved styles\n */\n\n/**\n * Resolves node styles\n *\n * @param {Object} container\n * @returns {ResolveNodeStyles} resolve node styles\n */\nconst resolveNodeStyles = container => node => {\n  const style = computeStyle(container, node);\n  if (!node.children) return Object.assign({}, node, {\n    style\n  });\n  const children = node.children.map(resolveNodeStyles(container));\n  return Object.assign({}, node, {\n    style,\n    children\n  });\n};\n\n/**\n * Resolves page styles\n *\n * @param {Object} page document page\n * @returns {Object} document page with resolved styles\n */\nconst resolvePageStyles = page => {\n  var _page$props, _page$box, _page$box2, _page$props2, _page$style;\n  const dpi = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.dpi) || 72;\n  const width = ((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.width) || page.style.width;\n  const height = ((_page$box2 = page.box) === null || _page$box2 === void 0 ? void 0 : _page$box2.height) || page.style.height;\n  const orientation = ((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.orientation) || 'portrait';\n  const remBase = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.fontSize) || 18;\n  const container = {\n    width,\n    height,\n    orientation,\n    dpi,\n    remBase\n  };\n  return resolveNodeStyles(container)(page);\n};\n\n/**\n * Resolves document styles\n *\n * @param {Object} root document root\n * @returns {Object} document root with resolved styles\n */\nconst resolveStyles = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePageStyles);\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst getTransformStyle = s => node => {\n  var _node$style, _node$style2;\n  return isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style[s]) ? '50%' : (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2[s];\n};\n\n/**\n * Get node origin\n *\n * @param {Object} node\n * @returns {{ left?: number, top?: number }} node origin\n */\nconst getOrigin = node => {\n  if (!node.box) return {};\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const transformOriginX = getTransformStyle('transformOriginX')(node);\n  const transformOriginY = getTransformStyle('transformOriginY')(node);\n  const percentX = matchPercent(transformOriginX);\n  const percentY = matchPercent(transformOriginY);\n  const offsetX = percentX ? width * percentX.percent : transformOriginX;\n  const offsetY = percentY ? height * percentY.percent : transformOriginY;\n  return {\n    left: left + offsetX,\n    top: top + offsetY\n  };\n};\n\n/**\n * Resolve node origin\n *\n * @param {Object} node\n * @returns {Object} node with origin attribute\n */\nconst resolveNodeOrigin = node => {\n  const origin = getOrigin(node);\n  const newNode = Object.assign({}, node, {\n    origin\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(resolveNodeOrigin);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Resolve document origins\n *\n * @param {Object} root document root\n * @returns {Object} document root\n */\n\nconst resolveOrigin = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolveNodeOrigin);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\n/* eslint-disable no-plusplus */\n/* eslint-disable prefer-const */\n/* eslint-disable prefer-destructuring */\n\nconst getBookmarkValue = title => {\n  return typeof title === 'string' ? {\n    title,\n    fit: false,\n    expanded: false\n  } : title;\n};\nconst resolveBookmarks = node => {\n  let refs = 0;\n  const children = (node.children || []).slice(0);\n  const listToExplore = children.map(value => ({\n    value,\n    parent: null\n  }));\n  while (listToExplore.length > 0) {\n    var _child$props;\n    const element = listToExplore.shift();\n    const child = element.value;\n    let parent = element.parent;\n    if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.bookmark) {\n      var _parent;\n      const bookmark = getBookmarkValue(child.props.bookmark);\n      const ref = refs++;\n      const newHierarchy = {\n        ref,\n        parent: (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.ref,\n        ...bookmark\n      };\n      child.props.bookmark = newHierarchy;\n      parent = newHierarchy;\n    }\n    if (child.children) {\n      child.children.forEach(childNode => {\n        listToExplore.push({\n          value: childNode,\n          parent\n        });\n      });\n    }\n  }\n  return node;\n};\nconst VALID_ORIENTATIONS = ['portrait', 'landscape'];\n\n/**\n * Get page orientation. Defaults to portrait\n *\n * @param {Object} page object\n * @returns {string} page orientation\n */\nconst getOrientation = page => {\n  var _page$props;\n  const value = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.orientation) || 'portrait';\n  return VALID_ORIENTATIONS.includes(value) ? value : 'portrait';\n};\n\n/**\n * Return true if page is landscape\n *\n * @param {Object} page instance\n * @returns {boolean} is page landscape\n */\nconst isLandscape = page => getOrientation(page) === 'landscape';\n\n// Page sizes for 72dpi. 72dpi is used internally by pdfkit.\nconst PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n  ID1: [153, 243]\n};\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {string} value scalar value\n * @returns {Object} parsed value\n */\nconst parseValue = value => {\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|px)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value,\n    unit: undefined\n  };\n};\n\n/**\n * Transform given scalar value to 72dpi equivalent of size\n *\n * @param {string} value styles value\n * @param {number} inputDpi user defined dpi\n * @returns {Object} transformed value\n */\nconst transformUnit = (value, inputDpi) => {\n  const scalar = parseValue(value);\n  const outputDpi = 72;\n  const mmFactor = 1 / 25.4 * outputDpi;\n  const cmFactor = 1 / 2.54 * outputDpi;\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * outputDpi;\n    case 'mm':\n      return scalar.value * mmFactor;\n    case 'cm':\n      return scalar.value * cmFactor;\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n    default:\n      return scalar.value;\n  }\n};\nconst transformUnits = (_ref, dpi) => {\n  let {\n    width,\n    height\n  } = _ref;\n  return {\n    width: transformUnit(width, dpi),\n    height: transformUnit(height, dpi)\n  };\n};\n\n/**\n * Transforms array into size object\n *\n * @param {number[] | string[]} v array\n * @returns {{ width: number | string, height: number | string }} size object with width and height\n */\nconst toSizeObject = v => ({\n  width: v[0],\n  height: v[1]\n});\n\n/**\n * Flip size object\n *\n * @param {{ width: number, height: number }} v size object\n * @returns {{ width: number, height: number }} flipped size object\n */\nconst flipSizeObject = v => ({\n  width: v.height,\n  height: v.width\n});\n\n/**\n * Returns size object from a given string\n *\n * @param {string} v page size string\n * @returns {{ width: number, height: number }} size object with width and height\n */\nconst getStringSize = v => {\n  return toSizeObject(PAGE_SIZES[v.toUpperCase()]);\n};\n\n/**\n * Returns size object from a single number\n *\n * @param {number|string} n page size number\n * @returns {{ width: number|string, height: number|string }} size object with width and height\n */\nconst getNumberSize = n => toSizeObject([n, n]);\n\n/**\n * Return page size in an object { width, height }\n *\n * @param {Object} page instance\n * @returns {{ width: number, height: number }} size object with width and height\n */\nconst getSize = page => {\n  var _page$props, _page$props2;\n  const value = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.size) || 'A4';\n  const dpi = parseFloat(((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.dpi) || 72);\n  const type = typeof value;\n\n  /**\n   * @type {{ width: number, height: number }}\n   */\n  let size;\n  if (type === 'string') {\n    size = getStringSize(value);\n  } else if (Array.isArray(value)) {\n    size = transformUnits(toSizeObject(value), dpi);\n  } else if (type === 'number') {\n    size = transformUnits(getNumberSize(value), dpi);\n  } else {\n    size = transformUnits(value, dpi);\n  }\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\n/**\n * Resolves page size\n *\n * @param {Object} page\n * @returns {Object} page with resolved size in style attribute\n */\nconst resolvePageSize = page => {\n  const size = getSize(page);\n  const style = flatten(page.style || {});\n  const box = page.box || {};\n  return {\n    ...page,\n    box,\n    style: {\n      ...style,\n      ...size\n    }\n  };\n};\n\n/**\n * Resolves page sizes\n *\n * @param {Object} root document root\n * @returns {Object} document root with resolved page sizes\n */\nconst resolvePageSizes = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePageSize);\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst isFixed = node => {\n  var _node$props;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fixed) === true;\n};\n\n/**\n * Get line index at given height\n *\n * @param {Object} node\n * @param {number} height\n */\nconst lineIndexAtHeight = (node, height) => {\n  let y = 0;\n  if (!node.lines) return 0;\n  for (let i = 0; i < node.lines.length; i += 1) {\n    const line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n  return node.lines.length;\n};\n\n/**\n * Get height for given text line index\n *\n * @param {Object} node\n * @param {number} index\n */\nconst heightAtLineIndex = (node, index) => {\n  let counter = 0;\n  if (!node.lines) return counter;\n  for (let i = 0; i < index; i += 1) {\n    const line = node.lines[i];\n    if (!line) break;\n    counter += line.box.height;\n  }\n  return counter;\n};\nconst getLineBreak = (node, height) => {\n  const top = get(node, ['box', 'top'], 0);\n  const widows = get(node, ['props', 'widows'], 2);\n  const orphans = get(node, ['props', 'orphans'], 2);\n  const linesQuantity = node.lines.length;\n  const slicedLine = lineIndexAtHeight(node, height - top);\n  if (slicedLine === 0) {\n    return 0;\n  }\n  if (linesQuantity < orphans) {\n    return linesQuantity;\n  }\n  if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  }\n  if (linesQuantity === orphans + widows) {\n    return orphans;\n  }\n  if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n  return slicedLine;\n};\n\n// Also receives contentArea in case it's needed\nconst splitText = (node, height) => {\n  const slicedLineIndex = getLineBreak(node, height);\n  const currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  const nextHeight = node.box.height - currentHeight;\n  const current = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      height: currentHeight,\n      borderBottomWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    },\n    lines: node.lines.slice(0, slicedLineIndex)\n  });\n  const next = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      top: 0,\n      height: nextHeight,\n      borderTopWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    },\n    lines: node.lines.slice(slicedLineIndex)\n  });\n  return [current, next];\n};\nconst getTop$1 = node => {\n  var _node$box;\n  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;\n};\nconst hasFixedHeight = node => {\n  var _node$style;\n  return !isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height);\n};\nconst splitNode = (node, height) => {\n  if (!node) return [null, null];\n  const nodeTop = getTop$1(node);\n  const current = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      borderBottomWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    }\n  });\n  current.style.height = height - nodeTop;\n  const nextHeight = hasFixedHeight(node) ? node.box.height - (height - nodeTop) : null;\n  const next = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      top: 0,\n      borderTopWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    }\n  });\n  if (nextHeight) {\n    next.style.height = nextHeight;\n  }\n  return [current, next];\n};\nconst NON_WRAP_TYPES = [P.Svg, P.Note, P.Image, P.Canvas];\nconst getWrap = node => {\n  var _node$props;\n  if (NON_WRAP_TYPES.includes(node.type)) return false;\n  return isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.wrap) ? true : node.props.wrap;\n};\nconst getComputedPadding = (node, edge) => {\n  const {\n    yogaNode\n  } = node;\n  return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ paddingTop: number, paddingRight: number, paddingBottom: number, paddingLeft: number }} paddings\n */\nconst getPadding = node => {\n  const {\n    style,\n    box\n  } = node;\n  const paddingTop = getComputedPadding(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  const paddingRight = getComputedPadding(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  const paddingBottom = getComputedPadding(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  const paddingLeft = getComputedPadding(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  return {\n    paddingTop,\n    paddingRight,\n    paddingBottom,\n    paddingLeft\n  };\n};\nconst getWrapArea = page => {\n  var _page$style;\n  const {\n    paddingBottom\n  } = getPadding(page);\n  const height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n  return height - paddingBottom;\n};\nconst getContentArea = page => {\n  var _page$style;\n  const height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n  const {\n    paddingTop,\n    paddingBottom\n  } = getPadding(page);\n  return height - paddingBottom - paddingTop;\n};\nconst isString = value => typeof value === 'string';\nconst isNumber = value => typeof value === 'number';\nconst isFragment = value => value && value.type === Symbol.for('react.fragment');\n\n/**\n * Transforms a react element instance to internal element format.\n *\n * Can return multiple instances in the case of arrays or fragments.\n *\n * @param {Object} element React element\n * @returns {Object[]} parsed React elements\n */\nconst createInstances = element => {\n  if (!element) return [];\n  if (isString(element) || isNumber(element)) {\n    return [{\n      type: TextInstance,\n      value: `${element}`\n    }];\n  }\n  if (isFragment(element)) {\n    return createInstances(element.props.children);\n  }\n  if (Array.isArray(element)) {\n    return element.reduce((acc, el) => acc.concat(createInstances(el)), []);\n  }\n  if (!isString(element.type)) {\n    return createInstances(element.type(element.props));\n  }\n  const {\n    type,\n    props: {\n      style = {},\n      children = [],\n      ...props\n    }\n  } = element;\n  const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);\n  return [{\n    type,\n    style,\n    props,\n    box: {},\n    children: nextChildren\n  }];\n};\n\n/* eslint-disable no-continue */\n\nconst getBreak = node => {\n  var _node$props;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.break) || false;\n};\nconst getMinPresenceAhead = node => {\n  var _node$props2;\n  return ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.minPresenceAhead) || 0;\n};\nconst getFurthestEnd = elements => Math.max(...elements.map(node => node.box.top + node.box.height));\nconst getEndOfMinPresenceAhead = child => {\n  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);\n};\nconst getEndOfPresence = (child, futureElements) => {\n  const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);\n  const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter(node => {\n    var _node$props3;\n    return !((_node$props3 = node.props) !== null && _node$props3 !== void 0 && _node$props3.fixed);\n  }));\n  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);\n};\nconst shouldBreak = (child, futureElements, height) => {\n  var _child$props;\n  if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.fixed) return false;\n  const shouldSplit = height < child.box.top + child.box.height;\n  const canWrap = getWrap(child);\n\n  // Calculate the y coordinate where the desired presence of the child ends\n  const endOfPresence = getEndOfPresence(child, futureElements);\n  // If the child is already at the top of the page, breaking won't improve its presence\n  // (as long as react-pdf does not support breaking into differently sized containers)\n  const breakingImprovesPresence = child.box.top > child.box.marginTop;\n  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height && breakingImprovesPresence;\n};\nconst IGNORABLE_CODEPOINTS = [8232,\n// LINE_SEPARATOR\n8233 // PARAGRAPH_SEPARATOR\n];\nconst buildSubsetForFont = font => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n  if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n    return acc;\n  }\n  return [...acc, String.fromCharCode(codePoint)];\n}, []);\nconst ignoreChars = fragments => fragments.map(fragment => {\n  const charSubset = buildSubsetForFont(fragment.attributes.font);\n  const subsetRegex = new RegExp(charSubset.join('|'));\n  return {\n    string: fragment.string.replace(subsetRegex, ''),\n    attributes: fragment.attributes\n  };\n});\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\nconst isImage$1 = node => node.type === P.Image;\nconst isTextInstance$2 = node => node.type === P.TextInstance;\n\n/**\n * Get textkit fragments of given node object\n *\n * @param {Object} fontStore font store\n * @param {Object} instance node\n * @param {string} [parentLink] parent link\n * @param {number} [level] fragment level\n * @returns {Object[]} text fragments\n */\nconst getFragments = function (fontStore, instance, parentLink, level) {\n  var _instance$props, _instance$props2;\n  if (level === void 0) {\n    level = 0;\n  }\n  if (!instance) return [{\n    string: ''\n  }];\n  let fragments = [];\n  const {\n    color = 'black',\n    direction = 'ltr',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textAlign,\n    lineHeight,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    letterSpacing,\n    textIndent,\n    opacity,\n    verticalAlign\n  } = instance.style;\n  const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n  const font = fontFamilies.map(fontFamilyName => {\n    if (typeof fontFamilyName !== 'string') return fontFamilyName;\n    const opts = {\n      fontFamily: fontFamilyName,\n      fontWeight,\n      fontStyle\n    };\n    const obj = fontStore ? fontStore.getFont(opts) : null;\n    return obj ? obj.data : fontFamilyName;\n  });\n\n  // Don't pass main background color to textkit. Will be rendered by the render package instead\n  const backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n  const attributes = {\n    font,\n    color,\n    opacity,\n    fontSize,\n    lineHeight,\n    direction,\n    verticalAlign,\n    backgroundColor,\n    indent: textIndent,\n    characterSpacing: letterSpacing,\n    strikeStyle: textDecorationStyle,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strike: textDecoration === 'line-through' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strikeColor: textDecorationColor || color,\n    underlineColor: textDecorationColor || color,\n    link: parentLink || ((_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.src) || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.href),\n    align: textAlign || (direction === 'rtl' ? 'right' : 'left')\n  };\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n    if (isImage$1(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: {\n          ...attributes,\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        }\n      });\n    } else if (isTextInstance$2(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments(fontStore, child, attributes.link, level + 1));\n    }\n  }\n  for (let i = 0; i < PREPROCESSORS.length; i += 1) {\n    const preprocessor = PREPROCESSORS[i];\n    fragments = preprocessor(fragments);\n  }\n  return fragments;\n};\n\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} fontStore font store\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\nconst getAttributedString = (fontStore, instance) => {\n  const fragments = getFragments(fontStore, instance);\n  return fromFragments(fragments);\n};\nconst engines = {\n  bidi,\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution\n};\nconst engine = layoutEngine(engines);\nconst getMaxLines = node => {\n  var _node$style;\n  return (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.maxLines;\n};\nconst getTextOverflow = node => {\n  var _node$style2;\n  return (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.textOverflow;\n};\n\n/**\n * Get layout container for specific text node\n *\n * @param {number} width\n * @param {number} height\n * @param {Object} node\n * @returns {Object} layout container\n */\nconst getContainer = (width, height, node) => {\n  const maxLines = getMaxLines(node);\n  const textOverflow = getTextOverflow(node);\n  return {\n    x: 0,\n    y: 0,\n    width,\n    maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow\n  };\n};\n\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = (fontStore, node) => ({\n  hyphenationPenalty: node.props.hyphenationPenalty,\n  shrinkWhitespaceFactor: {\n    before: -0.5,\n    after: -0.5\n  },\n  hyphenationCallback: node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null\n});\n\n/**\n * Get text lines for given node\n *\n * @param {Object} node node\n * @param {number} width container width\n * @param {number} height container height\n * @param {number} fontStore font store\n * @returns {Object[]} layout lines\n */\nconst layoutText = (node, width, height, fontStore) => {\n  const attributedString = getAttributedString(fontStore, node);\n  const container = getContainer(width, height, node);\n  const options = getLayoutOptions(fontStore, node);\n  const lines = engine(attributedString, container, options);\n  return lines.reduce((acc, line) => [...acc, ...line], []);\n};\nconst isType$2 = type => node => node.type === type;\nconst isSvg$2 = isType$2(P.Svg);\nconst isText$4 = isType$2(P.Text);\nconst shouldIterate = node => !isSvg$2(node) && !isText$4(node);\nconst shouldLayoutText = node => isText$4(node) && !node.lines;\n\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layout node\n */\nconst resolveTextLayout = (node, fontStore) => {\n  if (shouldLayoutText(node)) {\n    const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n    const height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n\n    // eslint-disable-next-line no-param-reassign\n    node.lines = layoutText(node, width, height, fontStore);\n  }\n  if (shouldIterate(node)) {\n    if (!node.children) return node;\n    const mapChild = child => resolveTextLayout(child, fontStore);\n    const children = node.children.map(mapChild);\n    return Object.assign({}, node, {\n      children\n    });\n  }\n  return node;\n};\nconst BASE_INHERITABLE_PROPERTIES = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'textTransform', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nconst TEXT_INHERITABLE_PROPERTIES = [...BASE_INHERITABLE_PROPERTIES, 'backgroundColor'];\nconst isSvg$1 = node => node.type === P.Svg;\nconst isText$3 = node => node.type === P.Text;\n\n// Merge style values\nconst mergeValues = (styleName, value, inheritedValue) => {\n  switch (styleName) {\n    case 'textDecoration':\n      {\n        // merge not none and not false textDecoration values to one rule\n        return [inheritedValue, value].filter(v => v && v !== 'none').join(' ');\n      }\n    default:\n      return value;\n  }\n};\n\n// Merge inherited and node styles\nconst merge = (inheritedStyles, style) => {\n  const mergedStyles = {\n    ...inheritedStyles\n  };\n  Object.entries(style).forEach(_ref => {\n    let [styleName, value] = _ref;\n    mergedStyles[styleName] = mergeValues(styleName, value, inheritedStyles[styleName]);\n  });\n  return mergedStyles;\n};\n\n/**\n * @typedef {Function} MergeStyles\n * @param {Object} node\n * @returns {Object} node with styles merged\n */\n\n/**\n * Merges styles with node\n *\n * @param {Object} inheritedStyles style object\n * @returns {MergeStyles} merge styles function\n */\nconst mergeStyles = inheritedStyles => node => {\n  const style = merge(inheritedStyles, node.style || {});\n  return Object.assign({}, node, {\n    style\n  });\n};\n\n/**\n * Inherit style values from the root to the leafs\n *\n * @param {Object} node document root\n * @returns {Object} document root with inheritance\n *\n */\nconst resolveInheritance = node => {\n  if (isSvg$1(node)) return node;\n  if (!node.children) return node;\n  const inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;\n  const inheritStyles = pick(inheritableProperties, node.style || {});\n  const resolveChild = compose(resolveInheritance, mergeStyles(inheritStyles));\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst getComputedMargin = (node, edge) => {\n  const {\n    yogaNode\n  } = node;\n  return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ marginTop: number, marginRight: number, marginBottom: number, marginLeft: number }} margins\n */\nconst getMargin = node => {\n  const {\n    style,\n    box\n  } = node;\n  const marginTop = getComputedMargin(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.marginTop) || (style === null || style === void 0 ? void 0 : style.marginTop) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  const marginRight = getComputedMargin(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.marginRight) || (style === null || style === void 0 ? void 0 : style.marginRight) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  const marginBottom = getComputedMargin(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  const marginLeft = getComputedMargin(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  };\n};\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ top: number, right: number, bottom: number, left: number }} position\n */\nconst getPosition = node => {\n  const {\n    yogaNode\n  } = node;\n  return {\n    top: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedTop()) || 0,\n    right: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedRight()) || 0,\n    bottom: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedBottom()) || 0,\n    left: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedLeft()) || 0\n  };\n};\nconst DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0\n};\n\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ width: number, height: number }} dimensions\n */\nconst getDimension = node => {\n  const {\n    yogaNode\n  } = node;\n  if (!yogaNode) return DEFAULT_DIMENSION;\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight()\n  };\n};\nconst getComputedBorder = (yogaNode, edge) => yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ borderTopWidth: number, borderRightWidth: number, borderBottomWidth: number, borderLeftWidth: number }} border widths\n */\nconst getBorderWidth = node => {\n  const {\n    yogaNode\n  } = node;\n  return {\n    borderTopWidth: getComputedBorder(yogaNode, Yoga.Edge.Top),\n    borderRightWidth: getComputedBorder(yogaNode, Yoga.Edge.Right),\n    borderBottomWidth: getComputedBorder(yogaNode, Yoga.Edge.Bottom),\n    borderLeftWidth: getComputedBorder(yogaNode, Yoga.Edge.Left)\n  };\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param {string} value display\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setDisplay = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    yogaNode.setDisplay(value === 'none' ? Yoga.Display.None : Yoga.Display.Flex);\n  }\n  return node;\n};\nconst OVERFLOW = {\n  hidden: Yoga.Overflow.Hidden,\n  scroll: Yoga.Overflow.Scroll\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param {string} value overflow value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setOverflow = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const overflow = OVERFLOW[value] || Yoga.Overflow.Visible;\n    yogaNode.setOverflow(overflow);\n  }\n  return node;\n};\nconst FLEX_WRAP = {\n  wrap: Yoga.Wrap.Wrap,\n  'wrap-reverse': Yoga.Wrap.WrapReverse\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param {string} value flex wrap value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexWrap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    const flexWrap = FLEX_WRAP[value] || Yoga.Wrap.NoWrap;\n    yogaNode.setFlexWrap(flexWrap);\n  }\n  return node;\n};\n\n/* eslint-disable no-unused-expressions */\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * @typedef {Function} YogaValueSetter\n * @param {any} value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param {string} attr property\n * @param {number} [edge] edge\n * @returns {YogaValueSetter} node instance wrapper\n */\nconst setYogaValue = (attr, edge) => value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const hasEdge = !isNil(edge);\n    const fixedMethod = `set${upperFirst(attr)}`;\n    const autoMethod = `${fixedMethod}Auto`;\n    const percentMethod = `${fixedMethod}Percent`;\n    const percent = matchPercent(value);\n    if (percent && !yogaNode[percentMethod]) {\n      throw new Error(`You can't pass percentage values to ${attr} property`);\n    }\n    if (percent) {\n      if (hasEdge) {\n        var _yogaNode$percentMeth;\n        (_yogaNode$percentMeth = yogaNode[percentMethod]) === null || _yogaNode$percentMeth === void 0 ? void 0 : _yogaNode$percentMeth.call(yogaNode, edge, percent.value);\n      } else {\n        var _yogaNode$percentMeth2;\n        (_yogaNode$percentMeth2 = yogaNode[percentMethod]) === null || _yogaNode$percentMeth2 === void 0 ? void 0 : _yogaNode$percentMeth2.call(yogaNode, percent.value);\n      }\n    } else if (value === 'auto') {\n      if (hasEdge) {\n        var _yogaNode$autoMethod;\n        (_yogaNode$autoMethod = yogaNode[autoMethod]) === null || _yogaNode$autoMethod === void 0 ? void 0 : _yogaNode$autoMethod.call(yogaNode, edge);\n      } else {\n        var _yogaNode$autoMethod2;\n        (_yogaNode$autoMethod2 = yogaNode[autoMethod]) === null || _yogaNode$autoMethod2 === void 0 ? void 0 : _yogaNode$autoMethod2.call(yogaNode);\n      }\n    } else if (hasEdge) {\n      var _yogaNode$fixedMethod;\n      (_yogaNode$fixedMethod = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod === void 0 ? void 0 : _yogaNode$fixedMethod.call(yogaNode, edge, value);\n    } else {\n      var _yogaNode$fixedMethod2;\n      (_yogaNode$fixedMethod2 = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod2 === void 0 ? void 0 : _yogaNode$fixedMethod2.call(yogaNode, value);\n    }\n  }\n  return node;\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param {number} value flex grow value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexGrow = value => node => {\n  return setYogaValue('flexGrow')(value || 0)(node);\n};\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param {number} flex basis value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\nconst ALIGN = {\n  'flex-start': Yoga.Align.FlexStart,\n  center: Yoga.Align.Center,\n  'flex-end': Yoga.Align.FlexEnd,\n  stretch: Yoga.Align.Stretch,\n  baseline: Yoga.Align.Baseline,\n  'space-between': Yoga.Align.SpaceBetween,\n  'space-around': Yoga.Align.SpaceAround,\n  'space-evenly': Yoga.Align.SpaceEvenly\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * @typedef {Function} AlignSetter\n * @param {string} value align value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\n\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param {string} attr specific align property\n * @returns {AlignSetter} align setter\n */\nconst setAlign = attr => value => node => {\n  const {\n    yogaNode\n  } = node;\n  const defaultValue = attr === 'items' ? Yoga.Align.Stretch : Yoga.Align.Auto;\n  if (yogaNode) {\n    const align = ALIGN[value] || defaultValue;\n    yogaNode[`setAlign${upperFirst(attr)}`](align);\n  }\n  return node;\n};\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param {string} align value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setAlignSelf = setAlign('self');\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param {string} align value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setAlignItems = setAlign('items');\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param {number} value flex shrink value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexShrink = value => node => {\n  return setYogaValue('flexShrink')(value || 1)(node);\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param {number} value ratio\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setAspectRatio = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setAspectRatio(value);\n  }\n  return node;\n};\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param {string} align value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setAlignContent = setAlign('content');\nconst POSITION = {\n  absolute: Yoga.PositionType.Absolute,\n  relative: Yoga.PositionType.Relative,\n  static: Yoga.PositionType.Static\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param {string} value position position type\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setPositionType = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setPositionType(POSITION[value]);\n  }\n  return node;\n};\nconst FLEX_DIRECTIONS = {\n  row: Yoga.FlexDirection.Row,\n  'row-reverse': Yoga.FlexDirection.RowReverse,\n  'column-reverse': Yoga.FlexDirection.ColumnReverse\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param {string} value flex direction value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexDirection = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    const flexDirection = FLEX_DIRECTIONS[value] || Yoga.FlexDirection.Column;\n    yogaNode.setFlexDirection(flexDirection);\n  }\n  return node;\n};\nconst JUSTIFY_CONTENT = {\n  center: Yoga.Justify.Center,\n  'flex-end': Yoga.Justify.FlexEnd,\n  'space-between': Yoga.Justify.SpaceBetween,\n  'space-around': Yoga.Justify.SpaceAround,\n  'space-evenly': Yoga.Justify.SpaceEvenly\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param {string} value justify content value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setJustifyContent = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const justifyContent = JUSTIFY_CONTENT[value] || Yoga.Justify.FlexStart;\n    yogaNode.setJustifyContent(justifyContent);\n  }\n  return node;\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param {number} margin margin top\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginTop = setYogaValue('margin', Yoga.Edge.Top);\n\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param {number} margin margin right\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginRight = setYogaValue('margin', Yoga.Edge.Right);\n\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param {number} margin margin bottom\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginBottom = setYogaValue('margin', Yoga.Edge.Bottom);\n\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param {number} margin margin left\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginLeft = setYogaValue('margin', Yoga.Edge.Left);\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param {number} padding padding top\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingTop = setYogaValue('padding', Yoga.Edge.Top);\n\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param {number} padding padding right\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingRight = setYogaValue('padding', Yoga.Edge.Right);\n\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param {number} padding padding bottom\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingBottom = setYogaValue('padding', Yoga.Edge.Bottom);\n\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param {number} padding padding left\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingLeft = setYogaValue('padding', Yoga.Edge.Left);\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param {number} border border top width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderTop = setYogaValue('border', Yoga.Edge.Top);\n\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param {number} border border right width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderRight = setYogaValue('border', Yoga.Edge.Right);\n\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param {number} border border bottom width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderBottom = setYogaValue('border', Yoga.Edge.Bottom);\n\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param {number} border border left width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderLeft = setYogaValue('border', Yoga.Edge.Left);\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param {number} position position top\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionTop = setYogaValue('position', Yoga.Edge.Top);\n\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param {number} position position right\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionRight = setYogaValue('position', Yoga.Edge.Right);\n\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param {number} position position bottom\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionBottom = setYogaValue('position', Yoga.Edge.Bottom);\n\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param {number} position position left\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionLeft = setYogaValue('position', Yoga.Edge.Left);\n\n/**\n * Set width to node's Yoga instance\n *\n * @param {number} width\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setWidth = setYogaValue('width');\n\n/**\n * Set min width to node's Yoga instance\n *\n * @param {number} min width\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMinWidth = setYogaValue('minWidth');\n\n/**\n * Set max width to node's Yoga instance\n *\n * @param {number} max width\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMaxWidth = setYogaValue('maxWidth');\n\n/**\n * Set height to node's Yoga instance\n *\n * @param {number} height\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setHeight = setYogaValue('height');\n\n/**\n * Set min height to node's Yoga instance\n *\n * @param {number} min height\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMinHeight = setYogaValue('minHeight');\n\n/**\n * Set max height to node's Yoga instance\n *\n * @param {number} max height\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMaxHeight = setYogaValue('maxHeight');\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set rowGap value to node's Yoga instance\n *\n * @param {number} value gap value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setRowGap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setGap(Yoga.Gutter.Row, value);\n  }\n  return node;\n};\n\n/**\n * Set columnGap value to node's Yoga instance\n *\n * @param {number} value gap value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setColumnGap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setGap(Yoga.Gutter.Column, value);\n  }\n  return node;\n};\nconst getAspectRatio = viewbox => {\n  if (!viewbox) return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n\n/**\n * @typedef {Function} MeasureSvg\n * @param {number} width\n * @param {number} widthMode\n * @param {number} height\n * @param {number} heightMode\n * @returns {{ width: number, height: number }} svg width and height\n */\n\n/**\n * Yoga svg measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureSvg} measure svg\n */\nconst measureCanvas$1 = (page, node) => (width, widthMode, height, heightMode) => {\n  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n  if (widthMode === Yoga.MeasureMode.Exactly || widthMode === Yoga.MeasureMode.AtMost) {\n    return {\n      width,\n      height: width / aspectRatio\n    };\n  }\n  if (heightMode === Yoga.MeasureMode.Exactly) {\n    return {\n      width: height * aspectRatio\n    };\n  }\n  return {};\n};\n\n/**\n * Get lines width (if any)\n *\n * @param {Object} node\n * @returns {number} lines width\n */\nconst linesWidth = node => {\n  if (!node.lines) return 0;\n  return Math.max(0, ...node.lines.map(line => line.xAdvance));\n};\n\n/**\n * Get lines height (if any)\n *\n * @param {Object} node\n * @returns {number} lines height\n */\nconst linesHeight = node => {\n  if (!node.lines) return -1;\n  return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\n\n/* eslint-disable no-param-reassign */\n\nconst ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n\n/**\n * @typedef {Function} MeasureText\n * @param {number} width\n * @param {number} widthMode\n * @param {number} height\n * @returns {{ width: number, height: number }} text width and height\n */\n\n/**\n * Yoga text measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Object} fontStore\n * @returns {MeasureText} measure text function\n */\nconst measureText = (page, node, fontStore) => (width, widthMode, height) => {\n  if (widthMode === Yoga.MeasureMode.Exactly) {\n    if (!node.lines) node.lines = layoutText(node, width, height, fontStore);\n    return {\n      height: linesHeight(node)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.AtMost) {\n    var _node$style;\n    const alignFactor = ALIGNMENT_FACTORS[(_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.textAlign] || 0;\n    if (!node.lines) {\n      node.lines = layoutText(node, width, height, fontStore);\n      node.alignOffset = (width - linesWidth(node)) * alignFactor; // Compensate align in variable width containers\n    }\n    return {\n      height: linesHeight(node),\n      width: Math.min(width, linesWidth(node))\n    };\n  }\n  return {};\n};\n\n/**\n * Get image ratio\n *\n * @param {Object} node image node\n * @returns {number} image ratio\n */\nconst getRatio = node => {\n  var _node$image;\n  return (_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data ? node.image.width / node.image.height : 1;\n};\n\n/**\n * Checks if page has auto height\n *\n * @param {Object} page\n * @returns {boolean} is page height auto\n */\nconst isHeightAuto = page => {\n  var _page$box;\n  return isNil((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.height);\n};\nconst SAFETY_HEIGHT$1 = 10;\n\n/**\n * @typedef {Function} MeasureImage\n * @param {number} width\n * @param {number} widthMode\n * @param {number} height\n * @param {number} heightMode\n * @returns {{ width: number, height: number }} image width and height\n */\n\n/**\n * Yoga image measure function\n *\n * @param {Object} page page\n * @param {Object} node node\n * @returns {MeasureImage} measure image\n */\nconst measureImage = (page, node) => (width, widthMode, height, heightMode) => {\n  const imageRatio = getRatio(node);\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;\n\n  // Skip measure if image data not present yet\n  if (!node.image) return {\n    width: 0,\n    height: 0\n  };\n  if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.Undefined) {\n    const scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(pageArea, scaledHeight)\n    };\n  }\n  if (heightMode === Yoga.MeasureMode.Exactly && (widthMode === Yoga.MeasureMode.AtMost || widthMode === Yoga.MeasureMode.Undefined)) {\n    return {\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.AtMost) {\n    const scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(height, pageArea, scaledHeight)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.AtMost && heightMode === Yoga.MeasureMode.AtMost) {\n    if (imageRatio > 1) {\n      return {\n        width,\n        height: Math.min(width / imageRatio, height)\n      };\n    }\n    return {\n      height,\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n  return {\n    height,\n    width\n  };\n};\n\n/* eslint-disable no-param-reassign */\n\nconst SAFETY_HEIGHT = 10;\nconst getMax = values => Math.max(-Infinity, ...values);\n\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n  const ctx = {};\n  const points = [];\n  const nil = () => ctx;\n  const addPoint = (x, y) => points.push([x, y]);\n  const moveTo = function () {\n    addPoint(...arguments);\n    return ctx;\n  };\n  const rect = (x, y, w, h) => {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n  const ellipse = (x, y, rx, ry) => {\n    ry = ry || rx;\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n    return ctx;\n  };\n  const polygon = function () {\n    points.push(...arguments);\n    return ctx;\n  };\n\n  // Change dimensions\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect;\n\n  // To be implemented\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil;\n\n  // These don't change dimensions\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n  ctx.getWidth = () => getMax(points.map(p => p[0]));\n  ctx.getHeight = () => getMax(points.map(p => p[1]));\n  return ctx;\n};\n\n/**\n * @typedef {Function} MeasureCanvas\n * @returns {{ width: number, height: number }} canvas width and height\n */\n\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureCanvas} measure canvas\n */\nconst measureCanvas = (page, node) => () => {\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;\n  const ctx = measureCtx();\n  node.props.paint(ctx);\n  const width = ctx.getWidth();\n  const height = Math.min(pageArea, ctx.getHeight());\n  return {\n    width,\n    height\n  };\n};\nconst isType$1 = type => node => node.type === type;\nconst isSvg = isType$1(P.Svg);\nconst isText$2 = isType$1(P.Text);\nconst isNote = isType$1(P.Note);\nconst isPage = isType$1(P.Page);\nconst isImage = isType$1(P.Image);\nconst isCanvas = isType$1(P.Canvas);\nconst isTextInstance$1 = isType$1(P.TextInstance);\nconst setNodeHeight = node => {\n  const value = isPage(node) ? node.box.height : node.style.height;\n  return setHeight(value);\n};\n\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst setYogaValues = node => {\n  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);\n};\n\n/**\n * @typedef {Function} InsertYogaNodes\n * @param {Object} child child node\n * @returns {Object} node\n */\n\n/**\n * Inserts child into parent' yoga node\n *\n * @param {Object} parent parent\n * @returns {InsertYogaNodes} insert yoga nodes\n */\nconst insertYogaNodes = parent => child => {\n  parent.insertChild(child.yogaNode, parent.getChildCount());\n  return child;\n};\nconst setMeasureFunc = (node, page, fontStore) => {\n  const {\n    yogaNode\n  } = node;\n  if (isText$2(node)) {\n    yogaNode.setMeasureFunc(measureText(page, node, fontStore));\n  }\n  if (isImage(node)) {\n    yogaNode.setMeasureFunc(measureImage(page, node));\n  }\n  if (isCanvas(node)) {\n    yogaNode.setMeasureFunc(measureCanvas(page, node));\n  }\n  if (isSvg(node)) {\n    yogaNode.setMeasureFunc(measureCanvas$1(page, node));\n  }\n  return node;\n};\nconst isLayoutElement = node => !isText$2(node) && !isNote(node) && !isSvg(node);\n\n/**\n * @typedef {Function} CreateYogaNodes\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @returns {CreateYogaNodes} create yoga nodes\n */\nconst createYogaNodes = (page, fontStore, yoga) => node => {\n  const yogaNode = yoga.node.create();\n  const result = Object.assign({}, node, {\n    yogaNode\n  });\n  setYogaValues(result);\n  if (isLayoutElement(node) && node.children) {\n    const resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore, yoga));\n    result.children = node.children.map(resolveChild);\n  }\n  setMeasureFunc(result, page, fontStore);\n  return result;\n};\n\n/**\n * Performs yoga calculation\n *\n * @param {Object} page page node\n * @returns {Object} page node\n */\nconst calculateLayout = page => {\n  page.yogaNode.calculateLayout();\n  return page;\n};\n\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param {Object} node\n * @returns {Object} node with box data\n */\nconst persistDimensions = node => {\n  if (isTextInstance$1(node)) return node;\n  const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));\n  const newNode = Object.assign({}, node, {\n    box\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(persistDimensions);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Removes yoga node from document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nconst destroyYogaNodes = node => {\n  const newNode = Object.assign({}, node);\n  delete newNode.yogaNode;\n  if (!node.children) return newNode;\n  const children = node.children.map(destroyYogaNodes);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Free yoga node from document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nconst freeYogaNodes = node => {\n  if (node.yogaNode) node.yogaNode.freeRecursive();\n  return node;\n};\n\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param {Object} page object\n * @returns {Object} page object with correct 'box' layout attributes\n */\nconst resolvePageDimensions = (page, fontStore, yoga) => {\n  if (isNil(page)) return null;\n  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore, yoga))(page);\n};\n\n/**\n * Calculates root object layout using Yoga.\n *\n * @param {Object} node root object\n * @param {Object} fontStore font store\n * @returns {Object} root object with correct 'box' layout attributes\n */\nconst resolveDimensions = (node, fontStore) => {\n  if (!node.children) return node;\n  const resolveChild = child => resolvePageDimensions(child, fontStore, node.yoga);\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\n/* eslint-disable no-use-before-define */\n/* eslint-disable no-continue */\n/* eslint-disable prefer-destructuring */\n\nconst isText$1 = node => node.type === P.Text;\n\n// Prevent splitting elements by low decimal numbers\nconst SAFETY_THRESHOLD = 0.001;\nconst assingChildren = (children, node) => Object.assign({}, node, {\n  children\n});\nconst getTop = node => {\n  var _node$box;\n  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;\n};\nconst allFixed = nodes => nodes.every(isFixed);\nconst isDynamic = node => {\n  var _node$props;\n  return !isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.render);\n};\nconst relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);\nconst warnUnavailableSpace = node => {\n  console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);\n};\nconst splitNodes = (height, contentArea, nodes) => {\n  const currentChildren = [];\n  const nextChildren = [];\n  for (let i = 0; i < nodes.length; i += 1) {\n    const child = nodes[i];\n    const futureNodes = nodes.slice(i + 1);\n    const futureFixedNodes = futureNodes.filter(isFixed);\n    const nodeTop = getTop(child);\n    const nodeHeight = child.box.height;\n    const isOutside = height <= nodeTop;\n    const shouldBreak$1 = shouldBreak(child, futureNodes, height);\n    const shouldSplit = height + SAFETY_THRESHOLD < nodeTop + nodeHeight;\n    const canWrap = getWrap(child);\n    const fitsInsidePage = nodeHeight <= contentArea;\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n    if (isOutside) {\n      const box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      const next = Object.assign({}, child, {\n        box\n      });\n      nextChildren.push(next);\n      continue;\n    }\n    if (!fitsInsidePage && !canWrap) {\n      currentChildren.push(child);\n      nextChildren.push(...futureNodes);\n      warnUnavailableSpace(child);\n      break;\n    }\n    if (shouldBreak$1) {\n      const box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      const props = Object.assign({}, child.props, {\n        wrap: true,\n        break: false\n      });\n      const next = Object.assign({}, child, {\n        box,\n        props\n      });\n      currentChildren.push(...futureFixedNodes);\n      nextChildren.push(next, ...futureNodes);\n      break;\n    }\n    if (shouldSplit) {\n      const [currentChild, nextChild] = split(child, height, contentArea);\n\n      // All children are moved to the next page, it doesn't make sense to show the parent on the current page\n      if (child.children.length > 0 && currentChild.children.length === 0) {\n        // But if the current page is empty then we can just include the parent on the current page\n        if (currentChildren.length === 0) {\n          currentChildren.push(child, ...futureFixedNodes);\n          nextChildren.push(...futureNodes);\n        } else {\n          const box = Object.assign({}, child.box, {\n            top: child.box.top - height\n          });\n          const next = Object.assign({}, child, {\n            box\n          });\n          currentChildren.push(...futureFixedNodes);\n          nextChildren.push(next, ...futureNodes);\n        }\n        break;\n      }\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n      continue;\n    }\n    currentChildren.push(child);\n  }\n  return [currentChildren, nextChildren];\n};\nconst splitChildren = (height, contentArea, node) => {\n  const children = node.children || [];\n  const availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, contentArea, children);\n};\nconst splitView = (node, height, contentArea) => {\n  const [currentNode, nextNode] = splitNode(node, height);\n  const [currentChilds, nextChildren] = splitChildren(height, contentArea, node);\n  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];\n};\nconst split = (node, height, contentArea) => isText$1(node) ? splitText(node, height) : splitView(node, height, contentArea);\nconst shouldResolveDynamicNodes = node => {\n  const children = node.children || [];\n  return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\nconst resolveDynamicNodes = (props, node) => {\n  const isNodeDynamic = isDynamic(node);\n\n  // Call render prop on dynamic nodes and append result to children\n  const resolveChildren = function (children) {\n    if (children === void 0) {\n      children = [];\n    }\n    if (isNodeDynamic) {\n      const res = node.props.render(props);\n      return createInstances(res).filter(Boolean).map(n => resolveDynamicNodes(props, n));\n    }\n    return children.map(c => resolveDynamicNodes(props, c));\n  };\n\n  // We reset dynamic text box so it can be computed again later on\n  const resetHeight = isNodeDynamic && isText$1(node);\n  const box = resetHeight ? {\n    ...node.box,\n    height: 0\n  } : node.box;\n  const children = resolveChildren(node.children);\n  const lines = isNodeDynamic ? null : node.lines;\n  return Object.assign({}, node, {\n    box,\n    lines,\n    children\n  });\n};\nconst resolveDynamicPage = (props, page, fontStore, yoga) => {\n  if (shouldResolveDynamicNodes(page)) {\n    const resolvedPage = resolveDynamicNodes(props, page);\n    return relayoutPage(resolvedPage, fontStore, yoga);\n  }\n  return page;\n};\nconst splitPage = (page, pageNumber, fontStore, yoga) => {\n  const wrapArea = getWrapArea(page);\n  const contentArea = getContentArea(page);\n  const dynamicPage = resolveDynamicPage({\n    pageNumber\n  }, page, fontStore, yoga);\n  const height = page.style.height;\n  const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);\n  const relayout = node => relayoutPage(node, fontStore, yoga);\n  const currentBox = {\n    ...page.box,\n    height\n  };\n  const currentPage = relayout(Object.assign({}, page, {\n    box: currentBox,\n    children: currentChilds\n  }));\n  if (nextChilds.length === 0 || allFixed(nextChilds)) return [currentPage, null];\n  const nextBox = omit('height', page.box);\n  const nextProps = omit('bookmark', page.props);\n  const nextPage = relayout(Object.assign({}, page, {\n    props: nextProps,\n    box: nextBox,\n    children: nextChilds\n  }));\n  return [currentPage, nextPage];\n};\nconst resolvePageIndices = (fontStore, yoga, page, pageNumber, pages) => {\n  const totalPages = pages.length;\n  const props = {\n    totalPages,\n    pageNumber: pageNumber + 1,\n    subPageNumber: page.subPageNumber + 1,\n    subPageTotalPages: page.subPageTotalPages\n  };\n  return resolveDynamicPage(props, page, fontStore, yoga);\n};\nconst assocSubPageData = subpages => {\n  return subpages.map((page, i) => ({\n    ...page,\n    subPageNumber: i,\n    subPageTotalPages: subpages.length\n  }));\n};\nconst dissocSubPageData = page => {\n  return omit(['subPageNumber', 'subPageTotalPages'], page);\n};\nconst paginate = (page, pageNumber, fontStore, yoga) => {\n  var _page$props;\n  if (!page) return [];\n  if (((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.wrap) === false) return [page];\n  let splittedPage = splitPage(page, pageNumber, fontStore, yoga);\n  const pages = [splittedPage[0]];\n  let nextPage = splittedPage[1];\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore, yoga);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n  return pages;\n};\n\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param {Object} doc node\n * @param {Object} fontStore font store\n * @returns {Object} layout node\n */\nconst resolvePagination = (doc, fontStore) => {\n  let pages = [];\n  let pageNumber = 1;\n  for (let i = 0; i < doc.children.length; i += 1) {\n    const page = doc.children[i];\n    let subpages = paginate(page, pageNumber, fontStore, doc.yoga);\n    subpages = assocSubPageData(subpages);\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n  pages = pages.map(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return dissocSubPageData(resolvePageIndices(fontStore, doc.yoga, ...args));\n  });\n  return assingChildren(pages, doc);\n};\n\n/**\n * @typedef {Function} ResolvePageHorizontalPadding\n * @param {string} value padding value\n * @returns {Object} translated padding value\n */\n\n/**\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param {Object} container page container\n * @returns {ResolvePageHorizontalPadding} resolve page horizontal padding\n */\nconst resolvePageHorizontalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.width : value;\n};\n\n/**\n * @typedef {Function} ResolvePageVerticalPadding\n * @param {string} padding value\n * @returns {Object} translated padding value\n */\n\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param {Object} container page container\n * @returns {ResolvePageVerticalPadding} resolve page vertical padding\n */\nconst resolvePageVerticalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.height : value;\n};\n\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param {Object} page\n * @returns {Object} page with fixed paddings\n */\nconst resolvePagePaddings = page => {\n  const container = page.style;\n  const style = evolve({\n    paddingTop: resolvePageVerticalPadding(container),\n    paddingLeft: resolvePageHorizontalPadding(container),\n    paddingRight: resolvePageHorizontalPadding(container),\n    paddingBottom: resolvePageVerticalPadding(container)\n  }, page.style);\n  return Object.assign({}, page, {\n    style\n  });\n};\n\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param {Object} root document root\n * @returns {Object} document root with translated page paddings\n */\nconst resolvePagesPaddings = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePagePaddings);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\n/**\n * @typedef {Function} ResolveRadius\n * @param {string | number} value border radius value\n * @returns {number} resolved radius value\n */\n\n/**\n *\n * @param {{ width: number, height: number }} container width and height\n * @returns {ResolveRadius} resolve radius function\n */\nconst resolveRadius = container => value => {\n  if (!value) return undefined;\n  const match = matchPercent(value);\n  return match ? match.percent * Math.min(container.width, container.height) : value;\n};\n\n/**\n * Transforms percent border radius into fixed values\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolvePercentRadius = node => {\n  const style = evolve({\n    borderTopLeftRadius: resolveRadius(node.box),\n    borderTopRightRadius: resolveRadius(node.box),\n    borderBottomRightRadius: resolveRadius(node.box),\n    borderBottomLeftRadius: resolveRadius(node.box)\n  }, node.style || {});\n  const newNode = Object.assign({}, node, {\n    style\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(resolvePercentRadius);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Transform percent height into fixed\n *\n * @param {number} height\n * @returns {number} height\n */\nconst transformHeight = (pageArea, height) => {\n  const match = matchPercent(height);\n  return match ? match.percent * pageArea : height;\n};\n\n/**\n * Get page area (height minus paddings)\n *\n * @param {Object} page\n * @returns {number} page area\n */\nconst getPageArea = page => {\n  var _page$style, _page$style2;\n  const pageHeight = page.style.height;\n  const pagePaddingTop = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.paddingTop) || 0;\n  const pagePaddingBottom = ((_page$style2 = page.style) === null || _page$style2 === void 0 ? void 0 : _page$style2.paddingBottom) || 0;\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n\n/**\n * Transform node percent height to fixed\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {Object} transformed node\n */\nconst resolveNodePercentHeight = (page, node) => {\n  var _page$style3, _node$style;\n  if (isNil((_page$style3 = page.style) === null || _page$style3 === void 0 ? void 0 : _page$style3.height)) return node;\n  if (isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height)) return node;\n  const pageArea = getPageArea(page);\n  const height = transformHeight(pageArea, node.style.height);\n  const style = Object.assign({}, node.style, {\n    height\n  });\n  return Object.assign({}, node, {\n    style\n  });\n};\n\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param {Object} page\n * @returns {Object} transformed page\n */\nconst resolvePagePercentHeight = page => {\n  if (!page.children) return page;\n  const resolveChild = child => resolveNodePercentHeight(page, child);\n  const children = page.children.map(resolveChild);\n  return Object.assign({}, page, {\n    children\n  });\n};\n\n/**\n * Transform all page immediate children with percent height to fixed.\n * This is needed for computing correct dimensions on pre-pagination layout.\n *\n * @param {Object} root document root\n * @returns {Object} transformed document root\n */\nconst resolvePercentHeight = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePagePercentHeight);\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst isType = type => node => node.type === type;\nconst isLink = isType(P.Link);\nconst isText = isType(P.Text);\nconst isTextInstance = isType(P.TextInstance);\n\n/**\n * Checks if node has render prop\n *\n * @param {Object} node\n * @returns {boolean} has render prop?\n */\nconst hasRenderProp = node => {\n  var _node$props;\n  return !!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.render);\n};\n\n/**\n * Checks if node is text type (Text or TextInstance)\n *\n * @param {Object} node\n * @returns {boolean} are all children text instances?\n */\nconst isTextType = node => isText(node) || isTextInstance(node);\n\n/**\n * Checks if is tet link that needs to be wrapped in Text\n *\n * @param {Object} node\n * @returns {boolean} are all children text instances?\n */\nconst isTextLink = node => {\n  const children = node.children || [];\n\n  // Text string inside a Link\n  if (children.every(isTextInstance)) return true;\n\n  // Text node inside a Link\n  if (children.every(isText)) return false;\n  return children.every(isTextType);\n};\n\n/**\n * Wraps node children inside Text node\n *\n * @param {Object} node\n * @returns {boolean} node with intermediate Text child\n */\nconst wrapText = node => {\n  const textElement = {\n    type: P.Text,\n    props: {},\n    style: {},\n    box: {},\n    children: node.children\n  };\n  return Object.assign({}, node, {\n    children: [textElement]\n  });\n};\nconst transformLink = node => {\n  if (!isLink(node)) return node;\n\n  // If has render prop substitute the instance by a Text, that will\n  // ultimately render the inline Link via the textkit PDF renderer.\n  if (hasRenderProp(node)) return Object.assign({}, node, {\n    type: P.Text\n  });\n\n  // If is a text link (either contains Text or TextInstalce), wrap it\n  // inside a Text element so styles are applied correctly\n\n  if (isTextLink(node)) return wrapText(node);\n  return node;\n};\n\n/**\n * Transforms Link layout to correctly render text and dynamic rendered links\n *\n * @param {Object} node\n * @returns {Object} node with link substitution\n */\nconst resolveLinkSubstitution = node => {\n  if (!node.children) return node;\n  const resolveChild = compose(transformLink, resolveLinkSubstitution);\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);\nexport { layout as default };","map":{"version":3,"names":["upperFirst","capitalize","last","pick","compose","evolve","mapValues","matchPercent","isNil","get","castArray","omit","asyncCompose","P","TextInstance","stylesheet","transformColor","processTransform","flatten","layoutEngine","bidi","linebreaker","justification","textDecoration","scriptItemizer","wordHyphenation","PDFFont","Yoga","loadYoga","loadYoga$1","emojiRegex","resolveImage","fromFragments","fragments","offset","string","runs","forEach","fragment","push","start","end","length","attributes","transformText","text","transformation","toUpperCase","toLowerCase","StandardFont","constructor","src","name","open","encode","str","layout","encoded","positions","stringIndices","map","_","i","glyphs","g","glyph","getGlyph","parseInt","advanceWidth","glyphForCodePoint","codePoint","id","_font","codePoints","isLigature","font","characterToGlyph","hasGlyphForCodePoint","ascent","capHeight","xHeight","descent","lineGap","unitsPerEm","fontCache","IGNORED_CODE_POINTS","getFontSize","node","fontSize","getOrCreateFont","getFallbackFont","pickFontFromFontStack","fontStack","lastFont","fontStackWithFallback","includes","fontSubstitution","_ref","lastFontSize","lastIndex","index","res","run","defaultFont","chars","slice","j","char","codePointAt","scale","isTextInstance$4","type","engines$1","engine$1","getFragments$1","fontStore","instance","fill","fontFamily","fontWeight","fontStyle","textDecorationColor","textDecorationStyle","textTransform","opacity","props","_textDecoration","fontFamilies","fontFamilyName","opts","obj","getFont","data","color","underlineStyle","underline","underlineColor","strike","strikeStyle","strikeColor","children","child","value","getAttributedString$1","AlmostInfinity","shrinkWhitespaceFactor","before","after","layoutTspan","_node$props","_node$props2","attributedString","x","y","container","width","height","hyphenationCallback","getHyphenationCallback","layoutOptions","lines","flat","Object","assign","layoutText$1","isDefs","Defs","getDefs","defs","find","values","reduce","acc","_value$props","isNotDefs","detachDefs","filter","URL_REGEX","replaceDef","undefined","test","match","parseNodeDefs","clipPath","parseDefs","root","replaceDefs","parseViewbox","split","parseFloat","minX","minY","maxX","maxY","getContainer$1","viewbox","viewBox","SVG_INHERITED_PROPS","getInheritProps","inheritProps","inheritedProps","newChild","parseAspectRatio","replace","align","meetOrSlice","STYLE_PROPS","VERTICAL_PROPS","HORIZONTAL_PROPS","isType$3","isSvg$3","Svg","isText$5","Text","isTextInstance$3","transformPercent","key","percent","parsePercent","parseProps","x1","x2","y1","y2","r","rx","ry","cx","cy","stroke","stopOpacity","stopColor","transform","mergeStyles$1","style","removeNoneValues","removeNone","pickStyleProps","styleProps","parseSvgProps","preserveAspectRatio","wrapBetweenTspan","Tspan","addMissingTspan","resolveChild","parseText","resolveSvgNode","resolveChildren","resolveSvgRoot","resolveSvg","instancePromise","config","Config","create","setPointScaleFactor","Node","createWithConfig","resolveYoga","yoga","getZIndex","zIndex","shouldSort","Document","sortZIndex","a","b","za","zb","resolveZIndex","sortedChildren","sort","emojis","regex","reflect","promise","arguments","then","v","e","makeFetchEmojiImage","_removeVariationSelectors","getCodePoints","withVariationSelectors","Array","from","toString","join","buildEmojiUrl","emoji","source","url","format","builder","fetchEmojis","promises","matchAll","loading","emojiUrl","fetchEmojiImage","uri","image","embedEmojis","result","emojiSize","chunk","String","fromCharCode","attachment","yOffset","Math","floor","getSource","_node$props3","href","resolveSource","fetchImage","cache","console","warn","Error","message","isImage$2","Image","fetchAssets","_node$children","listToExplore","emojiSource","getEmojiSource","_n$style","n","shift","load","childNode","resolveAssets","Promise","all","isLink$1","Link","DEFAULT_LINK_STYLES","computeStyle","baseStyle","isArray","resolveNodeStyles","resolvePageStyles","page","_page$props","_page$box","_page$box2","_page$props2","_page$style","dpi","box","orientation","remBase","resolveStyles","getTransformStyle","s","_node$style","_node$style2","getOrigin","left","top","transformOriginX","transformOriginY","percentX","percentY","offsetX","offsetY","resolveNodeOrigin","origin","newNode","resolveOrigin","getBookmarkValue","title","fit","expanded","resolveBookmarks","refs","parent","_child$props","element","bookmark","_parent","ref","newHierarchy","VALID_ORIENTATIONS","getOrientation","isLandscape","PAGE_SIZES","A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10","B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10","C0","C1","C2","C3","C4","C5","C6","C7","C8","C9","C10","RA0","RA1","RA2","RA3","RA4","SRA0","SRA1","SRA2","SRA3","SRA4","EXECUTIVE","FOLIO","LEGAL","LETTER","TABLOID","ID1","parseValue","exec","unit","transformUnit","inputDpi","scalar","outputDpi","mmFactor","cmFactor","round","transformUnits","toSizeObject","flipSizeObject","getStringSize","getNumberSize","getSize","size","resolvePageSize","resolvePageSizes","isFixed","fixed","lineIndexAtHeight","line","heightAtLineIndex","counter","getLineBreak","widows","orphans","linesQuantity","slicedLine","splitText","slicedLineIndex","currentHeight","nextHeight","current","borderBottomWidth","marginBottom","paddingBottom","borderBottomLeftRadius","borderBottomRightRadius","next","borderTopWidth","marginTop","paddingTop","borderTopLeftRadius","borderTopRightRadius","getTop$1","_node$box","hasFixedHeight","splitNode","nodeTop","NON_WRAP_TYPES","Note","Canvas","getWrap","wrap","getComputedPadding","edge","yogaNode","getPadding","Edge","Top","paddingVertical","padding","paddingRight","Right","paddingHorizontal","Bottom","paddingLeft","Left","getWrapArea","getContentArea","isString","isNumber","isFragment","Symbol","for","createInstances","el","concat","nextChildren","getBreak","break","getMinPresenceAhead","minPresenceAhead","getFurthestEnd","elements","max","getEndOfMinPresenceAhead","getEndOfPresence","futureElements","afterMinPresenceAhead","endOfFurthestFutureElement","min","shouldBreak","shouldSplit","canWrap","endOfPresence","breakingImprovesPresence","IGNORABLE_CODEPOINTS","buildSubsetForFont","ignoreChars","charSubset","subsetRegex","RegExp","PREPROCESSORS","isImage$1","isTextInstance$2","getFragments","parentLink","level","_instance$props","_instance$props2","direction","textAlign","lineHeight","letterSpacing","textIndent","verticalAlign","backgroundColor","indent","characterSpacing","link","preprocessor","getAttributedString","engines","engine","getMaxLines","maxLines","getTextOverflow","textOverflow","getContainer","Infinity","truncateMode","getLayoutOptions","hyphenationPenalty","layoutText","options","isType$2","isSvg$2","isText$4","shouldIterate","shouldLayoutText","resolveTextLayout","mapChild","BASE_INHERITABLE_PROPERTIES","TEXT_INHERITABLE_PROPERTIES","isSvg$1","isText$3","mergeValues","styleName","inheritedValue","merge","inheritedStyles","mergedStyles","entries","mergeStyles","resolveInheritance","inheritableProperties","inheritStyles","getComputedMargin","getMargin","marginVertical","margin","marginRight","marginHorizontal","marginLeft","getPosition","getComputedTop","right","getComputedRight","bottom","getComputedBottom","getComputedLeft","DEFAULT_DIMENSION","getDimension","getComputedWidth","getComputedHeight","getComputedBorder","getBorderWidth","borderRightWidth","borderLeftWidth","setDisplay","Display","None","Flex","OVERFLOW","hidden","Overflow","Hidden","scroll","Scroll","setOverflow","overflow","Visible","FLEX_WRAP","Wrap","WrapReverse","setFlexWrap","flexWrap","NoWrap","setYogaValue","attr","hasEdge","fixedMethod","autoMethod","percentMethod","_yogaNode$percentMeth","call","_yogaNode$percentMeth2","_yogaNode$autoMethod","_yogaNode$autoMethod2","_yogaNode$fixedMethod","_yogaNode$fixedMethod2","setFlexGrow","setFlexBasis","ALIGN","Align","FlexStart","center","Center","FlexEnd","stretch","Stretch","baseline","Baseline","SpaceBetween","SpaceAround","SpaceEvenly","setAlign","defaultValue","Auto","setAlignSelf","setAlignItems","setFlexShrink","setAspectRatio","setAlignContent","POSITION","absolute","PositionType","Absolute","relative","Relative","static","Static","setPositionType","FLEX_DIRECTIONS","row","FlexDirection","Row","RowReverse","ColumnReverse","setFlexDirection","flexDirection","Column","JUSTIFY_CONTENT","Justify","setJustifyContent","justifyContent","setMarginTop","setMarginRight","setMarginBottom","setMarginLeft","setPaddingTop","setPaddingRight","setPaddingBottom","setPaddingLeft","setBorderTop","setBorderRight","setBorderBottom","setBorderLeft","setPositionTop","setPositionRight","setPositionBottom","setPositionLeft","setWidth","setMinWidth","setMaxWidth","setHeight","setMinHeight","setMaxHeight","setRowGap","setGap","Gutter","setColumnGap","getAspectRatio","measureCanvas$1","widthMode","heightMode","aspectRatio","MeasureMode","Exactly","AtMost","linesWidth","xAdvance","linesHeight","ALIGNMENT_FACTORS","measureText","alignFactor","alignOffset","getRatio","_node$image","isHeightAuto","SAFETY_HEIGHT$1","measureImage","imageRatio","imageMargin","pagePadding","pageArea","Undefined","scaledHeight","SAFETY_HEIGHT","getMax","measureCtx","ctx","points","nil","addPoint","moveTo","rect","w","h","ellipse","polygon","lineTo","circle","roundedRect","path","lineWidth","bezierCurveTo","quadraticCurveTo","rotate","translate","dash","clip","save","lineCap","restore","lineJoin","fillColor","miterLimit","strokeColor","fillOpacity","strokeOpacity","linearGradient","radialGradient","getWidth","p","getHeight","measureCanvas","paint","isType$1","isSvg","isText$2","isNote","isPage","Page","isImage","isCanvas","isTextInstance$1","setNodeHeight","setYogaValues","minWidth","maxWidth","minHeight","maxHeight","position","display","alignSelf","alignContent","alignItems","flexBasis","flexGrow","flexShrink","rowGap","columnGap","insertYogaNodes","insertChild","getChildCount","setMeasureFunc","isLayoutElement","createYogaNodes","calculateLayout","persistDimensions","destroyYogaNodes","freeYogaNodes","freeRecursive","resolvePageDimensions","resolveDimensions","isText$1","SAFETY_THRESHOLD","assingChildren","getTop","allFixed","nodes","every","isDynamic","render","relayoutPage","warnUnavailableSpace","splitNodes","contentArea","currentChildren","futureNodes","futureFixedNodes","nodeHeight","isOutside","shouldBreak$1","fitsInsidePage","currentChild","nextChild","splitChildren","availableHeight","splitView","currentNode","nextNode","currentChilds","shouldResolveDynamicNodes","some","resolveDynamicNodes","isNodeDynamic","Boolean","c","resetHeight","resolveDynamicPage","resolvedPage","splitPage","pageNumber","wrapArea","dynamicPage","nextChilds","relayout","currentBox","currentPage","nextBox","nextProps","nextPage","resolvePageIndices","pages","totalPages","subPageNumber","subPageTotalPages","assocSubPageData","subpages","dissocSubPageData","paginate","splittedPage","resolvePagination","doc","_len","args","_key","resolvePageHorizontalPadding","resolvePageVerticalPadding","resolvePagePaddings","resolvePagesPaddings","resolveRadius","resolvePercentRadius","transformHeight","getPageArea","_page$style2","pageHeight","pagePaddingTop","pagePaddingBottom","resolveNodePercentHeight","_page$style3","resolvePagePercentHeight","resolvePercentHeight","isType","isLink","isText","isTextInstance","hasRenderProp","isTextType","isTextLink","wrapText","textElement","transformLink","resolveLinkSubstitution","default"],"sources":["C:/Users/SHIVA CHAITANYA/Desktop/New Builds/BlogProject/node_modules/@react-pdf/layout/lib/index.js"],"sourcesContent":["import { upperFirst, capitalize, last, pick, compose, evolve, mapValues, matchPercent, isNil, get, castArray, omit, asyncCompose } from '@react-pdf/fns';\nimport * as P from '@react-pdf/primitives';\nimport { TextInstance } from '@react-pdf/primitives';\nimport stylesheet, { transformColor, processTransform, flatten } from '@react-pdf/stylesheet';\nimport layoutEngine, { bidi, linebreaker, justification, textDecoration, scriptItemizer, wordHyphenation } from '@react-pdf/textkit';\nimport { PDFFont } from '@react-pdf/pdfkit';\nimport * as Yoga from 'yoga-layout/load';\nimport { loadYoga as loadYoga$1 } from 'yoga-layout/load';\nimport emojiRegex from 'emoji-regex';\nimport resolveImage from '@react-pdf/image';\n\n/**\n * Create attributed string from text fragments\n *\n * @param {Object[]} fragments fragments\n * @returns {Object} attributed string\n */\nconst fromFragments = fragments => {\n  let offset = 0;\n  let string = '';\n  const runs = [];\n  fragments.forEach(fragment => {\n    string += fragment.string;\n    runs.push({\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string,\n    runs\n  };\n};\n\n/**\n * Apply transformation to text string\n *\n * @param {string} text\n * @param {string} transformation type\n * @returns {string} transformed text\n */\nconst transformText = (text, transformation) => {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n    case 'lowercase':\n      return text.toLowerCase();\n    case 'capitalize':\n      return capitalize(text);\n    case 'upperfirst':\n      return upperFirst(text);\n    default:\n      return text;\n  }\n};\n\n/* eslint-disable class-methods-use-this */\n\nclass StandardFont {\n  constructor(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n  encode(str) {\n    return this.src.encode(str);\n  }\n  layout(str) {\n    const [encoded, positions] = this.encode(str);\n    return {\n      positions,\n      stringIndices: positions.map((_, i) => i),\n      glyphs: encoded.map((g, i) => {\n        const glyph = this.getGlyph(parseInt(g, 16));\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      })\n    };\n  }\n  glyphForCodePoint(codePoint) {\n    const glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  }\n  getGlyph(id) {\n    return {\n      id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id)\n    };\n  }\n  hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  }\n\n  // Based on empirical observation\n  get ascent() {\n    return 900;\n  }\n\n  // Based on empirical observation\n  get capHeight() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n      case 'Times-BoldItalic':\n        return 650;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n      case 'Courier-BoldOblique':\n        return 550;\n      default:\n        return 690;\n    }\n  }\n\n  // Based on empirical observation\n  get xHeight() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n      case 'Times-BoldItalic':\n        return 440;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n      case 'Courier-BoldOblique':\n        return 390;\n      default:\n        return 490;\n    }\n  }\n\n  // Based on empirical observation\n  get descent() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n      case 'Times-BoldItalic':\n        return -220;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n      case 'Courier-BoldOblique':\n        return -230;\n      default:\n        return -200;\n    }\n  }\n  get lineGap() {\n    return 0;\n  }\n  get unitsPerEm() {\n    return 1000;\n  }\n}\n\nconst fontCache = {};\nconst IGNORED_CODE_POINTS = [173];\nconst getFontSize = node => node.attributes.fontSize || 12;\nconst getOrCreateFont = name => {\n  if (fontCache[name]) return fontCache[name];\n  const font = new StandardFont(name);\n  fontCache[name] = font;\n  return font;\n};\nconst getFallbackFont = () => getOrCreateFont('Helvetica');\nconst pickFontFromFontStack = (codePoint, fontStack, lastFont) => {\n  const fontStackWithFallback = [...fontStack, lastFont, getFallbackFont()];\n  for (let i = 0; i < fontStackWithFallback.length; i += 1) {\n    const font = fontStackWithFallback[i];\n    if (!IGNORED_CODE_POINTS.includes(codePoint) && font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return font;\n    }\n  }\n  return getFallbackFont();\n};\nconst fontSubstitution = () => _ref => {\n  let {\n    string,\n    runs\n  } = _ref;\n  let lastFont = null;\n  let lastFontSize = null;\n  let lastIndex = 0;\n  let index = 0;\n  const res = [];\n  for (let i = 0; i < runs.length; i += 1) {\n    const run = runs[i];\n    const defaultFont = run.attributes.font.map(font => typeof font === 'string' ? getOrCreateFont(font) : font);\n    if (string.length === 0) {\n      res.push({\n        start: 0,\n        end: 0,\n        attributes: {\n          font: defaultFont\n        }\n      });\n      break;\n    }\n    const chars = string.slice(run.start, run.end);\n    for (let j = 0; j < chars.length; j += 1) {\n      const char = chars[j];\n      const codePoint = char.codePointAt();\n      // If the default font does not have a glyph and the fallback font does, we use it\n      const font = pickFontFromFontStack(codePoint, defaultFont, lastFont);\n      const fontSize = getFontSize(run);\n\n      // If anything that would impact res has changed, update it\n      if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: lastFont,\n              scale: lastFontSize / lastFont.unitsPerEm\n            }\n          });\n        }\n        lastFont = font;\n        lastFontSize = fontSize;\n        lastIndex = index;\n      }\n      index += char.length;\n    }\n  }\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(last(runs));\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: lastFont,\n        scale: fontSize / lastFont.unitsPerEm\n      }\n    });\n  }\n  return {\n    string,\n    runs: res\n  };\n};\n\nconst isTextInstance$4 = node => node.type === P.TextInstance;\nconst engines$1 = {\n  bidi,\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution\n};\nconst engine$1 = layoutEngine(engines$1);\nconst getFragments$1 = (fontStore, instance) => {\n  if (!instance) return [{\n    string: ''\n  }];\n  const fragments = [];\n  const {\n    fill = 'black',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    opacity\n  } = instance.props;\n  const _textDecoration = instance.props.textDecoration;\n  const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n  const font = fontFamilies.map(fontFamilyName => {\n    if (typeof fontFamilyName !== 'string') return fontFamilyName;\n    const opts = {\n      fontFamily: fontFamilyName,\n      fontWeight,\n      fontStyle\n    };\n    const obj = fontStore ? fontStore.getFont(opts) : null;\n    return obj ? obj.data : fontFamilyName;\n  });\n  const attributes = {\n    font,\n    opacity,\n    fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: _textDecoration === 'underline' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    underlineColor: textDecorationColor || fill,\n    strike: _textDecoration === 'line-through' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill\n  };\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n    if (isTextInstance$4(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments$1(child));\n    }\n  }\n  return fragments;\n};\nconst getAttributedString$1 = (fontStore, instance) => fromFragments(getFragments$1(fontStore, instance));\nconst AlmostInfinity = 999999999999;\nconst shrinkWhitespaceFactor = {\n  before: -0.5,\n  after: -0.5\n};\nconst layoutTspan = fontStore => node => {\n  var _node$props, _node$props2;\n  const attributedString = getAttributedString$1(fontStore, node);\n  const x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;\n  const y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;\n  const container = {\n    x,\n    y,\n    width: AlmostInfinity,\n    height: AlmostInfinity\n  };\n  const hyphenationCallback = node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null;\n  const layoutOptions = {\n    hyphenationCallback,\n    shrinkWhitespaceFactor\n  };\n  const lines = engine$1(attributedString, container, layoutOptions).flat();\n  return Object.assign({}, node, {\n    lines\n  });\n};\nconst layoutText$1 = (fontStore, node) => {\n  if (!node.children) return node;\n  const children = node.children.map(layoutTspan(fontStore));\n  return Object.assign({}, node, {\n    children\n  });\n};\n\nconst isDefs = node => node.type === P.Defs;\nconst getDefs = node => {\n  const children = node.children || [];\n  const defs = children.find(isDefs) || {};\n  const values = defs.children || [];\n  return values.reduce((acc, value) => {\n    var _value$props;\n    const id = (_value$props = value.props) === null || _value$props === void 0 ? void 0 : _value$props.id;\n    if (id) acc[id] = value;\n    return acc;\n  }, {});\n};\n\nconst isNotDefs = node => node.type !== P.Defs;\nconst detachDefs = node => {\n  if (!node.children) return node;\n  const children = node.children.filter(isNotDefs);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\nconst replaceDef = (defs, value) => {\n  if (!value) return undefined;\n  if (!URL_REGEX.test(value)) return value;\n  const match = value.match(URL_REGEX);\n  return defs[match[1]];\n};\nconst parseNodeDefs = defs => node => {\n  var _node$props, _node$props2;\n  const fill = replaceDef(defs, (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fill);\n  const clipPath = replaceDef(defs, (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.clipPath);\n  const props = Object.assign({}, node.props, {\n    fill,\n    clipPath\n  });\n  const children = node.children ? node.children.map(parseNodeDefs(defs)) : undefined;\n  return Object.assign({}, node, {\n    props,\n    children\n  });\n};\nconst parseDefs = root => {\n  if (!root.children) return root;\n  const defs = getDefs(root);\n  const children = root.children.map(parseNodeDefs(defs));\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst replaceDefs = node => {\n  return detachDefs(parseDefs(node));\n};\n\nconst parseViewbox = value => {\n  if (!value) return null;\n  const values = value.split(/[,\\s]+/).map(parseFloat);\n  if (values.length !== 4) return null;\n  return {\n    minX: values[0],\n    minY: values[1],\n    maxX: values[2],\n    maxY: values[3]\n  };\n};\n\nconst getContainer$1 = node => {\n  const viewbox = parseViewbox(node.props.viewBox);\n  if (viewbox) {\n    return {\n      width: viewbox.maxX,\n      height: viewbox.maxY\n    };\n  }\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat(node.props.width),\n      height: parseFloat(node.props.height)\n    };\n  }\n  return {\n    width: 0,\n    height: 0\n  };\n};\n\nconst SVG_INHERITED_PROPS = ['x', 'y', 'clipPath', 'clipRule', 'opacity', 'fill', 'fillOpacity', 'fillRule', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeOpacity', 'strokeWidth', 'textAnchor', 'dominantBaseline', 'color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nconst getInheritProps = node => {\n  const props = node.props || {};\n  return pick(SVG_INHERITED_PROPS, props);\n};\nconst inheritProps = node => {\n  if (!node.children) return node;\n  const inheritedProps = getInheritProps(node);\n  const children = node.children.map(child => {\n    const props = Object.assign({}, inheritedProps, child.props || {});\n    const newChild = Object.assign({}, child, {\n      props\n    });\n    return inheritProps(newChild);\n  });\n  return Object.assign({}, node, {\n    children\n  });\n};\n\nconst parseAspectRatio = value => {\n  const match = value.replace(/[\\s\\r\\t\\n]+/gm, ' ').replace(/^defer\\s/, '').split(' ');\n  const align = match[0] || 'xMidYMid';\n  const meetOrSlice = match[1] || 'meet';\n  return {\n    align,\n    meetOrSlice\n  };\n};\n\nconst STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray'];\nconst VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nconst HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\nconst isType$3 = type => node => node.type === type;\nconst isSvg$3 = isType$3(P.Svg);\nconst isText$5 = isType$3(P.Text);\nconst isTextInstance$3 = isType$3(P.TextInstance);\nconst transformPercent = container => props => mapValues(props, (value, key) => {\n  const match = matchPercent(value);\n  if (match && VERTICAL_PROPS.includes(key)) {\n    return match.percent * container.height;\n  }\n  if (match && HORIZONTAL_PROPS.includes(key)) {\n    return match.percent * container.width;\n  }\n  return value;\n});\nconst parsePercent = value => {\n  const match = matchPercent(value);\n  return match ? match.percent : parseFloat(value);\n};\nconst parseProps = container => node => {\n  let props = transformPercent(container)(node.props);\n  props = evolve({\n    x: parseFloat,\n    x1: parseFloat,\n    x2: parseFloat,\n    y: parseFloat,\n    y1: parseFloat,\n    y2: parseFloat,\n    r: parseFloat,\n    rx: parseFloat,\n    ry: parseFloat,\n    cx: parseFloat,\n    cy: parseFloat,\n    width: parseFloat,\n    height: parseFloat,\n    offset: parsePercent,\n    fill: transformColor,\n    opacity: parsePercent,\n    stroke: transformColor,\n    stopOpacity: parsePercent,\n    stopColor: transformColor,\n    transform: processTransform\n  }, props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst mergeStyles$1 = node => {\n  const style = node.style || {};\n  const props = Object.assign({}, style, node.props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst removeNoneValues = node => {\n  const removeNone = value => value === 'none' ? null : value;\n  const props = mapValues(node.props, removeNone);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst pickStyleProps = node => {\n  const props = node.props || {};\n  const styleProps = pick(STYLE_PROPS, props);\n  const style = Object.assign({}, styleProps, node.style || {});\n  return Object.assign({}, node, {\n    style\n  });\n};\nconst parseSvgProps = node => {\n  const props = evolve({\n    width: parseFloat,\n    height: parseFloat,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio\n  }, node.props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst wrapBetweenTspan = node => ({\n  type: P.Tspan,\n  props: {},\n  children: [node]\n});\nconst addMissingTspan = node => {\n  if (!isText$5(node)) return node;\n  if (!node.children) return node;\n  const resolveChild = child => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst parseText = fontStore => node => {\n  if (isText$5(node)) return layoutText$1(fontStore, node);\n  if (!node.children) return node;\n  const children = node.children.map(parseText(fontStore));\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst resolveSvgNode = container => compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);\nconst resolveChildren = container => node => {\n  if (!node.children) return node;\n  const resolveChild = compose(resolveChildren(container), resolveSvgNode(container));\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst resolveSvgRoot = (node, fontStore) => {\n  const container = getContainer$1(node);\n  return compose(replaceDefs, parseText(fontStore), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container))(node);\n};\n\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param {Object} node root node\n * @param {Object} fontStore font store\n * @returns {Object} root node\n */\nconst resolveSvg = (node, fontStore) => {\n  if (!node.children) return node;\n  const resolveChild = child => resolveSvg(child, fontStore);\n  const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore) : node;\n  const children = root.children.map(resolveChild);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\n/* eslint-disable import/prefer-default-export */\n\nlet instancePromise;\nconst loadYoga = async () => {\n  // Yoga WASM binaries must be asynchronously compiled and loaded\n  // to prevent Event emitter memory leak warnings, Yoga must be loaded only once\n  const instance = await (instancePromise ??= loadYoga$1());\n  const config = instance.Config.create();\n  config.setPointScaleFactor(0);\n  const node = {\n    create: () => instance.Node.createWithConfig(config)\n  };\n  return {\n    node\n  };\n};\n\nconst resolveYoga = async root => {\n  const yoga = await loadYoga();\n  return Object.assign({}, root, {\n    yoga\n  });\n};\n\nconst getZIndex = node => node.style.zIndex;\nconst shouldSort = node => node.type !== P.Document && node.type !== P.Svg;\nconst sortZIndex = (a, b) => {\n  const za = getZIndex(a);\n  const zb = getZIndex(b);\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n  return zb - za;\n};\n\n/**\n * Sort children by zIndex value\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolveZIndex = node => {\n  if (!node.children) return node;\n  const sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;\n  const children = sortedChildren.map(resolveZIndex);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\n/* eslint-disable no-cond-assign */\n\n// Caches emoji images data\nconst emojis = {};\nconst regex = emojiRegex();\nconst reflect = promise => function () {\n  return promise(...arguments).then(v => v, e => e);\n};\n\n// Returns a function to be able to mock resolveImage.\nconst makeFetchEmojiImage = () => reflect(resolveImage);\n\n/**\n * When an emoji as no variations, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst _removeVariationSelectors = x => x !== '️';\nconst getCodePoints = (string, withVariationSelectors) => Array.from(string).filter(withVariationSelectors ? () => true : _removeVariationSelectors).map(char => char.codePointAt(0).toString(16)).join('-');\nconst buildEmojiUrl = (emoji, source) => {\n  const {\n    url,\n    format,\n    builder,\n    withVariationSelectors\n  } = source;\n  if (typeof builder === 'function') {\n    return builder(getCodePoints(emoji, withVariationSelectors));\n  }\n  return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format}`;\n};\nconst fetchEmojis = (string, source) => {\n  if (!source || !source.url && !source.builder) return [];\n  const promises = [];\n  Array.from(string.matchAll(regex)).forEach(match => {\n    const emoji = match[0];\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      const emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      const fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(image => {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  });\n  return promises;\n};\nconst embedEmojis = fragments => {\n  const result = [];\n  for (let i = 0; i < fragments.length; i += 1) {\n    const fragment = fragments[i];\n    let lastIndex = 0;\n    Array.from(fragment.string.matchAll(regex)).forEach(match => {\n      const {\n        index\n      } = match;\n      const emoji = match[0];\n      const emojiSize = fragment.attributes.fontSize;\n      const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n\n      // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: {\n            ...fragment.attributes,\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          }\n        });\n      } else {\n        // If no emoji data, we try to use emojis in the font\n        result.push({\n          string: chunk,\n          attributes: fragment.attributes\n        });\n      }\n      lastIndex = index + emoji.length;\n    });\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Get image source\n *\n * @param {Object} node image node\n * @returns {string | Object} image src\n */\nconst getSource = node => {\n  var _node$props, _node$props2, _node$props3;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.src) || ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.source) || ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.href);\n};\n\n/**\n * Resolves `src` to `@react-pdf/image` interface.\n *\n * Also it handles factories and async sources.\n *\n * @param {string | Object | Function} src\n * @returns {Promise<Object>} resolved src\n */\nconst resolveSource = async src => {\n  const source = typeof src === 'function' ? await src() : await src;\n  return typeof source === 'string' ? {\n    uri: source\n  } : source;\n};\n\n/* eslint-disable no-param-reassign */\n\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param {Object} node\n */\nconst fetchImage = async node => {\n  const src = getSource(node);\n  const {\n    cache\n  } = node.props;\n  if (!src) {\n    console.warn(false, 'Image should receive either a \"src\" or \"source\" prop');\n    return;\n  }\n  try {\n    const source = await resolveSource(src);\n    if (!source) {\n      throw new Error(`Image's \"src\" or \"source\" prop returned ${source}`);\n    }\n    node.image = await resolveImage(source, {\n      cache\n    });\n    node.image.key = source.data ? source.data.toString() : source.uri;\n  } catch (e) {\n    node.image = {\n      width: 0,\n      height: 0,\n      key: null\n    };\n    console.warn(e.message);\n  }\n};\n\nconst isImage$2 = node => node.type === P.Image;\n\n/**\n * Get all asset promises that need to be resolved\n *\n * @param {Object} fontStore font store\n * @param {Object} node root node\n * @returns {Promise<void>[]} asset promises\n */\nconst fetchAssets = (fontStore, node) => {\n  var _node$children;\n  const promises = [];\n  const listToExplore = ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.slice(0)) || [];\n  const emojiSource = fontStore ? fontStore.getEmojiSource() : null;\n  while (listToExplore.length > 0) {\n    var _n$style;\n    const n = listToExplore.shift();\n    if (isImage$2(n)) {\n      promises.push(fetchImage(n));\n    }\n    if (fontStore && (_n$style = n.style) !== null && _n$style !== void 0 && _n$style.fontFamily) {\n      promises.push(fontStore.load(n.style));\n    }\n    if (typeof n === 'string') {\n      promises.push(...fetchEmojis(n, emojiSource));\n    }\n    if (typeof n.value === 'string') {\n      promises.push(...fetchEmojis(n.value, emojiSource));\n    }\n    if (n.children) {\n      n.children.forEach(childNode => {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n  return promises;\n};\n\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param {Object} node root node\n * @param {Object} fontStore font store\n * @returns {Promise<Object>} root node\n */\nconst resolveAssets = async (node, fontStore) => {\n  const promises = fetchAssets(fontStore, node);\n  await Promise.all(promises);\n  return node;\n};\n\nconst isLink$1 = node => node.type === P.Link;\nconst DEFAULT_LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline'\n};\n\n/**\n * Computes styles using stylesheet\n *\n * @param {Object} container\n * @param {Object} node document node\n * @returns {Object} computed styles\n */\nconst computeStyle = (container, node) => {\n  let baseStyle = node.style;\n  if (isLink$1(node)) {\n    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES, ...node.style] : [DEFAULT_LINK_STYLES, node.style];\n  }\n  return stylesheet(container, baseStyle);\n};\n\n/**\n * @typedef {Function} ResolveNodeStyles\n * @param {Object} node document node\n * @returns {Object} node (and subnodes) with resolved styles\n */\n\n/**\n * Resolves node styles\n *\n * @param {Object} container\n * @returns {ResolveNodeStyles} resolve node styles\n */\nconst resolveNodeStyles = container => node => {\n  const style = computeStyle(container, node);\n  if (!node.children) return Object.assign({}, node, {\n    style\n  });\n  const children = node.children.map(resolveNodeStyles(container));\n  return Object.assign({}, node, {\n    style,\n    children\n  });\n};\n\n/**\n * Resolves page styles\n *\n * @param {Object} page document page\n * @returns {Object} document page with resolved styles\n */\nconst resolvePageStyles = page => {\n  var _page$props, _page$box, _page$box2, _page$props2, _page$style;\n  const dpi = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.dpi) || 72;\n  const width = ((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.width) || page.style.width;\n  const height = ((_page$box2 = page.box) === null || _page$box2 === void 0 ? void 0 : _page$box2.height) || page.style.height;\n  const orientation = ((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.orientation) || 'portrait';\n  const remBase = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.fontSize) || 18;\n  const container = {\n    width,\n    height,\n    orientation,\n    dpi,\n    remBase\n  };\n  return resolveNodeStyles(container)(page);\n};\n\n/**\n * Resolves document styles\n *\n * @param {Object} root document root\n * @returns {Object} document root with resolved styles\n */\nconst resolveStyles = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePageStyles);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\nconst getTransformStyle = s => node => {\n  var _node$style, _node$style2;\n  return isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style[s]) ? '50%' : (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2[s];\n};\n\n/**\n * Get node origin\n *\n * @param {Object} node\n * @returns {{ left?: number, top?: number }} node origin\n */\nconst getOrigin = node => {\n  if (!node.box) return {};\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const transformOriginX = getTransformStyle('transformOriginX')(node);\n  const transformOriginY = getTransformStyle('transformOriginY')(node);\n  const percentX = matchPercent(transformOriginX);\n  const percentY = matchPercent(transformOriginY);\n  const offsetX = percentX ? width * percentX.percent : transformOriginX;\n  const offsetY = percentY ? height * percentY.percent : transformOriginY;\n  return {\n    left: left + offsetX,\n    top: top + offsetY\n  };\n};\n\n/**\n * Resolve node origin\n *\n * @param {Object} node\n * @returns {Object} node with origin attribute\n */\nconst resolveNodeOrigin = node => {\n  const origin = getOrigin(node);\n  const newNode = Object.assign({}, node, {\n    origin\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(resolveNodeOrigin);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Resolve document origins\n *\n * @param {Object} root document root\n * @returns {Object} document root\n */\n\nconst resolveOrigin = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolveNodeOrigin);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\n/* eslint-disable no-plusplus */\n/* eslint-disable prefer-const */\n/* eslint-disable prefer-destructuring */\n\nconst getBookmarkValue = title => {\n  return typeof title === 'string' ? {\n    title,\n    fit: false,\n    expanded: false\n  } : title;\n};\nconst resolveBookmarks = node => {\n  let refs = 0;\n  const children = (node.children || []).slice(0);\n  const listToExplore = children.map(value => ({\n    value,\n    parent: null\n  }));\n  while (listToExplore.length > 0) {\n    var _child$props;\n    const element = listToExplore.shift();\n    const child = element.value;\n    let parent = element.parent;\n    if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.bookmark) {\n      var _parent;\n      const bookmark = getBookmarkValue(child.props.bookmark);\n      const ref = refs++;\n      const newHierarchy = {\n        ref,\n        parent: (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.ref,\n        ...bookmark\n      };\n      child.props.bookmark = newHierarchy;\n      parent = newHierarchy;\n    }\n    if (child.children) {\n      child.children.forEach(childNode => {\n        listToExplore.push({\n          value: childNode,\n          parent\n        });\n      });\n    }\n  }\n  return node;\n};\n\nconst VALID_ORIENTATIONS = ['portrait', 'landscape'];\n\n/**\n * Get page orientation. Defaults to portrait\n *\n * @param {Object} page object\n * @returns {string} page orientation\n */\nconst getOrientation = page => {\n  var _page$props;\n  const value = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.orientation) || 'portrait';\n  return VALID_ORIENTATIONS.includes(value) ? value : 'portrait';\n};\n\n/**\n * Return true if page is landscape\n *\n * @param {Object} page instance\n * @returns {boolean} is page landscape\n */\nconst isLandscape = page => getOrientation(page) === 'landscape';\n\n// Page sizes for 72dpi. 72dpi is used internally by pdfkit.\nconst PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n  ID1: [153, 243]\n};\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {string} value scalar value\n * @returns {Object} parsed value\n */\nconst parseValue = value => {\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|px)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value,\n    unit: undefined\n  };\n};\n\n/**\n * Transform given scalar value to 72dpi equivalent of size\n *\n * @param {string} value styles value\n * @param {number} inputDpi user defined dpi\n * @returns {Object} transformed value\n */\nconst transformUnit = (value, inputDpi) => {\n  const scalar = parseValue(value);\n  const outputDpi = 72;\n  const mmFactor = 1 / 25.4 * outputDpi;\n  const cmFactor = 1 / 2.54 * outputDpi;\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * outputDpi;\n    case 'mm':\n      return scalar.value * mmFactor;\n    case 'cm':\n      return scalar.value * cmFactor;\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n    default:\n      return scalar.value;\n  }\n};\nconst transformUnits = (_ref, dpi) => {\n  let {\n    width,\n    height\n  } = _ref;\n  return {\n    width: transformUnit(width, dpi),\n    height: transformUnit(height, dpi)\n  };\n};\n\n/**\n * Transforms array into size object\n *\n * @param {number[] | string[]} v array\n * @returns {{ width: number | string, height: number | string }} size object with width and height\n */\nconst toSizeObject = v => ({\n  width: v[0],\n  height: v[1]\n});\n\n/**\n * Flip size object\n *\n * @param {{ width: number, height: number }} v size object\n * @returns {{ width: number, height: number }} flipped size object\n */\nconst flipSizeObject = v => ({\n  width: v.height,\n  height: v.width\n});\n\n/**\n * Returns size object from a given string\n *\n * @param {string} v page size string\n * @returns {{ width: number, height: number }} size object with width and height\n */\nconst getStringSize = v => {\n  return toSizeObject(PAGE_SIZES[v.toUpperCase()]);\n};\n\n/**\n * Returns size object from a single number\n *\n * @param {number|string} n page size number\n * @returns {{ width: number|string, height: number|string }} size object with width and height\n */\nconst getNumberSize = n => toSizeObject([n, n]);\n\n/**\n * Return page size in an object { width, height }\n *\n * @param {Object} page instance\n * @returns {{ width: number, height: number }} size object with width and height\n */\nconst getSize = page => {\n  var _page$props, _page$props2;\n  const value = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.size) || 'A4';\n  const dpi = parseFloat(((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.dpi) || 72);\n  const type = typeof value;\n\n  /**\n   * @type {{ width: number, height: number }}\n   */\n  let size;\n  if (type === 'string') {\n    size = getStringSize(value);\n  } else if (Array.isArray(value)) {\n    size = transformUnits(toSizeObject(value), dpi);\n  } else if (type === 'number') {\n    size = transformUnits(getNumberSize(value), dpi);\n  } else {\n    size = transformUnits(value, dpi);\n  }\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\n/**\n * Resolves page size\n *\n * @param {Object} page\n * @returns {Object} page with resolved size in style attribute\n */\nconst resolvePageSize = page => {\n  const size = getSize(page);\n  const style = flatten(page.style || {});\n  const box = page.box || {};\n  return {\n    ...page,\n    box,\n    style: {\n      ...style,\n      ...size\n    }\n  };\n};\n\n/**\n * Resolves page sizes\n *\n * @param {Object} root document root\n * @returns {Object} document root with resolved page sizes\n */\nconst resolvePageSizes = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePageSize);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\nconst isFixed = node => {\n  var _node$props;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fixed) === true;\n};\n\n/**\n * Get line index at given height\n *\n * @param {Object} node\n * @param {number} height\n */\nconst lineIndexAtHeight = (node, height) => {\n  let y = 0;\n  if (!node.lines) return 0;\n  for (let i = 0; i < node.lines.length; i += 1) {\n    const line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n  return node.lines.length;\n};\n\n/**\n * Get height for given text line index\n *\n * @param {Object} node\n * @param {number} index\n */\nconst heightAtLineIndex = (node, index) => {\n  let counter = 0;\n  if (!node.lines) return counter;\n  for (let i = 0; i < index; i += 1) {\n    const line = node.lines[i];\n    if (!line) break;\n    counter += line.box.height;\n  }\n  return counter;\n};\n\nconst getLineBreak = (node, height) => {\n  const top = get(node, ['box', 'top'], 0);\n  const widows = get(node, ['props', 'widows'], 2);\n  const orphans = get(node, ['props', 'orphans'], 2);\n  const linesQuantity = node.lines.length;\n  const slicedLine = lineIndexAtHeight(node, height - top);\n  if (slicedLine === 0) {\n    return 0;\n  }\n  if (linesQuantity < orphans) {\n    return linesQuantity;\n  }\n  if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  }\n  if (linesQuantity === orphans + widows) {\n    return orphans;\n  }\n  if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n  return slicedLine;\n};\n\n// Also receives contentArea in case it's needed\nconst splitText = (node, height) => {\n  const slicedLineIndex = getLineBreak(node, height);\n  const currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  const nextHeight = node.box.height - currentHeight;\n  const current = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      height: currentHeight,\n      borderBottomWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    },\n    lines: node.lines.slice(0, slicedLineIndex)\n  });\n  const next = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      top: 0,\n      height: nextHeight,\n      borderTopWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    },\n    lines: node.lines.slice(slicedLineIndex)\n  });\n  return [current, next];\n};\n\nconst getTop$1 = node => {\n  var _node$box;\n  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;\n};\nconst hasFixedHeight = node => {\n  var _node$style;\n  return !isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height);\n};\nconst splitNode = (node, height) => {\n  if (!node) return [null, null];\n  const nodeTop = getTop$1(node);\n  const current = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      borderBottomWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    }\n  });\n  current.style.height = height - nodeTop;\n  const nextHeight = hasFixedHeight(node) ? node.box.height - (height - nodeTop) : null;\n  const next = Object.assign({}, node, {\n    box: {\n      ...node.box,\n      top: 0,\n      borderTopWidth: 0\n    },\n    style: {\n      ...node.style,\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    }\n  });\n  if (nextHeight) {\n    next.style.height = nextHeight;\n  }\n  return [current, next];\n};\n\nconst NON_WRAP_TYPES = [P.Svg, P.Note, P.Image, P.Canvas];\nconst getWrap = node => {\n  var _node$props;\n  if (NON_WRAP_TYPES.includes(node.type)) return false;\n  return isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.wrap) ? true : node.props.wrap;\n};\n\nconst getComputedPadding = (node, edge) => {\n  const {\n    yogaNode\n  } = node;\n  return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ paddingTop: number, paddingRight: number, paddingBottom: number, paddingLeft: number }} paddings\n */\nconst getPadding = node => {\n  const {\n    style,\n    box\n  } = node;\n  const paddingTop = getComputedPadding(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  const paddingRight = getComputedPadding(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  const paddingBottom = getComputedPadding(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  const paddingLeft = getComputedPadding(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  return {\n    paddingTop,\n    paddingRight,\n    paddingBottom,\n    paddingLeft\n  };\n};\n\nconst getWrapArea = page => {\n  var _page$style;\n  const {\n    paddingBottom\n  } = getPadding(page);\n  const height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n  return height - paddingBottom;\n};\n\nconst getContentArea = page => {\n  var _page$style;\n  const height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n  const {\n    paddingTop,\n    paddingBottom\n  } = getPadding(page);\n  return height - paddingBottom - paddingTop;\n};\n\nconst isString = value => typeof value === 'string';\nconst isNumber = value => typeof value === 'number';\nconst isFragment = value => value && value.type === Symbol.for('react.fragment');\n\n/**\n * Transforms a react element instance to internal element format.\n *\n * Can return multiple instances in the case of arrays or fragments.\n *\n * @param {Object} element React element\n * @returns {Object[]} parsed React elements\n */\nconst createInstances = element => {\n  if (!element) return [];\n  if (isString(element) || isNumber(element)) {\n    return [{\n      type: TextInstance,\n      value: `${element}`\n    }];\n  }\n  if (isFragment(element)) {\n    return createInstances(element.props.children);\n  }\n  if (Array.isArray(element)) {\n    return element.reduce((acc, el) => acc.concat(createInstances(el)), []);\n  }\n  if (!isString(element.type)) {\n    return createInstances(element.type(element.props));\n  }\n  const {\n    type,\n    props: {\n      style = {},\n      children = [],\n      ...props\n    }\n  } = element;\n  const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);\n  return [{\n    type,\n    style,\n    props,\n    box: {},\n    children: nextChildren\n  }];\n};\n\n/* eslint-disable no-continue */\n\nconst getBreak = node => {\n  var _node$props;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.break) || false;\n};\nconst getMinPresenceAhead = node => {\n  var _node$props2;\n  return ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.minPresenceAhead) || 0;\n};\nconst getFurthestEnd = elements => Math.max(...elements.map(node => node.box.top + node.box.height));\nconst getEndOfMinPresenceAhead = child => {\n  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);\n};\nconst getEndOfPresence = (child, futureElements) => {\n  const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);\n  const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter(node => {\n    var _node$props3;\n    return !((_node$props3 = node.props) !== null && _node$props3 !== void 0 && _node$props3.fixed);\n  }));\n  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);\n};\nconst shouldBreak = (child, futureElements, height) => {\n  var _child$props;\n  if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.fixed) return false;\n  const shouldSplit = height < child.box.top + child.box.height;\n  const canWrap = getWrap(child);\n\n  // Calculate the y coordinate where the desired presence of the child ends\n  const endOfPresence = getEndOfPresence(child, futureElements);\n  // If the child is already at the top of the page, breaking won't improve its presence\n  // (as long as react-pdf does not support breaking into differently sized containers)\n  const breakingImprovesPresence = child.box.top > child.box.marginTop;\n  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height && breakingImprovesPresence;\n};\n\nconst IGNORABLE_CODEPOINTS = [8232,\n// LINE_SEPARATOR\n8233 // PARAGRAPH_SEPARATOR\n];\nconst buildSubsetForFont = font => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n  if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n    return acc;\n  }\n  return [...acc, String.fromCharCode(codePoint)];\n}, []);\nconst ignoreChars = fragments => fragments.map(fragment => {\n  const charSubset = buildSubsetForFont(fragment.attributes.font);\n  const subsetRegex = new RegExp(charSubset.join('|'));\n  return {\n    string: fragment.string.replace(subsetRegex, ''),\n    attributes: fragment.attributes\n  };\n});\n\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\nconst isImage$1 = node => node.type === P.Image;\nconst isTextInstance$2 = node => node.type === P.TextInstance;\n\n/**\n * Get textkit fragments of given node object\n *\n * @param {Object} fontStore font store\n * @param {Object} instance node\n * @param {string} [parentLink] parent link\n * @param {number} [level] fragment level\n * @returns {Object[]} text fragments\n */\nconst getFragments = function (fontStore, instance, parentLink, level) {\n  var _instance$props, _instance$props2;\n  if (level === void 0) {\n    level = 0;\n  }\n  if (!instance) return [{\n    string: ''\n  }];\n  let fragments = [];\n  const {\n    color = 'black',\n    direction = 'ltr',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textAlign,\n    lineHeight,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    letterSpacing,\n    textIndent,\n    opacity,\n    verticalAlign\n  } = instance.style;\n  const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n  const font = fontFamilies.map(fontFamilyName => {\n    if (typeof fontFamilyName !== 'string') return fontFamilyName;\n    const opts = {\n      fontFamily: fontFamilyName,\n      fontWeight,\n      fontStyle\n    };\n    const obj = fontStore ? fontStore.getFont(opts) : null;\n    return obj ? obj.data : fontFamilyName;\n  });\n\n  // Don't pass main background color to textkit. Will be rendered by the render package instead\n  const backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n  const attributes = {\n    font,\n    color,\n    opacity,\n    fontSize,\n    lineHeight,\n    direction,\n    verticalAlign,\n    backgroundColor,\n    indent: textIndent,\n    characterSpacing: letterSpacing,\n    strikeStyle: textDecorationStyle,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strike: textDecoration === 'line-through' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strikeColor: textDecorationColor || color,\n    underlineColor: textDecorationColor || color,\n    link: parentLink || ((_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.src) || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.href),\n    align: textAlign || (direction === 'rtl' ? 'right' : 'left')\n  };\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n    if (isImage$1(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: {\n          ...attributes,\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        }\n      });\n    } else if (isTextInstance$2(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments(fontStore, child, attributes.link, level + 1));\n    }\n  }\n  for (let i = 0; i < PREPROCESSORS.length; i += 1) {\n    const preprocessor = PREPROCESSORS[i];\n    fragments = preprocessor(fragments);\n  }\n  return fragments;\n};\n\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} fontStore font store\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\nconst getAttributedString = (fontStore, instance) => {\n  const fragments = getFragments(fontStore, instance);\n  return fromFragments(fragments);\n};\n\nconst engines = {\n  bidi,\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution\n};\nconst engine = layoutEngine(engines);\nconst getMaxLines = node => {\n  var _node$style;\n  return (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.maxLines;\n};\nconst getTextOverflow = node => {\n  var _node$style2;\n  return (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.textOverflow;\n};\n\n/**\n * Get layout container for specific text node\n *\n * @param {number} width\n * @param {number} height\n * @param {Object} node\n * @returns {Object} layout container\n */\nconst getContainer = (width, height, node) => {\n  const maxLines = getMaxLines(node);\n  const textOverflow = getTextOverflow(node);\n  return {\n    x: 0,\n    y: 0,\n    width,\n    maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow\n  };\n};\n\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = (fontStore, node) => ({\n  hyphenationPenalty: node.props.hyphenationPenalty,\n  shrinkWhitespaceFactor: {\n    before: -0.5,\n    after: -0.5\n  },\n  hyphenationCallback: node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null\n});\n\n/**\n * Get text lines for given node\n *\n * @param {Object} node node\n * @param {number} width container width\n * @param {number} height container height\n * @param {number} fontStore font store\n * @returns {Object[]} layout lines\n */\nconst layoutText = (node, width, height, fontStore) => {\n  const attributedString = getAttributedString(fontStore, node);\n  const container = getContainer(width, height, node);\n  const options = getLayoutOptions(fontStore, node);\n  const lines = engine(attributedString, container, options);\n  return lines.reduce((acc, line) => [...acc, ...line], []);\n};\n\nconst isType$2 = type => node => node.type === type;\nconst isSvg$2 = isType$2(P.Svg);\nconst isText$4 = isType$2(P.Text);\nconst shouldIterate = node => !isSvg$2(node) && !isText$4(node);\nconst shouldLayoutText = node => isText$4(node) && !node.lines;\n\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layout node\n */\nconst resolveTextLayout = (node, fontStore) => {\n  if (shouldLayoutText(node)) {\n    const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n    const height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n\n    // eslint-disable-next-line no-param-reassign\n    node.lines = layoutText(node, width, height, fontStore);\n  }\n  if (shouldIterate(node)) {\n    if (!node.children) return node;\n    const mapChild = child => resolveTextLayout(child, fontStore);\n    const children = node.children.map(mapChild);\n    return Object.assign({}, node, {\n      children\n    });\n  }\n  return node;\n};\n\nconst BASE_INHERITABLE_PROPERTIES = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'textTransform', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nconst TEXT_INHERITABLE_PROPERTIES = [...BASE_INHERITABLE_PROPERTIES, 'backgroundColor'];\nconst isSvg$1 = node => node.type === P.Svg;\nconst isText$3 = node => node.type === P.Text;\n\n// Merge style values\nconst mergeValues = (styleName, value, inheritedValue) => {\n  switch (styleName) {\n    case 'textDecoration':\n      {\n        // merge not none and not false textDecoration values to one rule\n        return [inheritedValue, value].filter(v => v && v !== 'none').join(' ');\n      }\n    default:\n      return value;\n  }\n};\n\n// Merge inherited and node styles\nconst merge = (inheritedStyles, style) => {\n  const mergedStyles = {\n    ...inheritedStyles\n  };\n  Object.entries(style).forEach(_ref => {\n    let [styleName, value] = _ref;\n    mergedStyles[styleName] = mergeValues(styleName, value, inheritedStyles[styleName]);\n  });\n  return mergedStyles;\n};\n\n/**\n * @typedef {Function} MergeStyles\n * @param {Object} node\n * @returns {Object} node with styles merged\n */\n\n/**\n * Merges styles with node\n *\n * @param {Object} inheritedStyles style object\n * @returns {MergeStyles} merge styles function\n */\nconst mergeStyles = inheritedStyles => node => {\n  const style = merge(inheritedStyles, node.style || {});\n  return Object.assign({}, node, {\n    style\n  });\n};\n\n/**\n * Inherit style values from the root to the leafs\n *\n * @param {Object} node document root\n * @returns {Object} document root with inheritance\n *\n */\nconst resolveInheritance = node => {\n  if (isSvg$1(node)) return node;\n  if (!node.children) return node;\n  const inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;\n  const inheritStyles = pick(inheritableProperties, node.style || {});\n  const resolveChild = compose(resolveInheritance, mergeStyles(inheritStyles));\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\nconst getComputedMargin = (node, edge) => {\n  const {\n    yogaNode\n  } = node;\n  return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ marginTop: number, marginRight: number, marginBottom: number, marginLeft: number }} margins\n */\nconst getMargin = node => {\n  const {\n    style,\n    box\n  } = node;\n  const marginTop = getComputedMargin(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.marginTop) || (style === null || style === void 0 ? void 0 : style.marginTop) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  const marginRight = getComputedMargin(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.marginRight) || (style === null || style === void 0 ? void 0 : style.marginRight) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  const marginBottom = getComputedMargin(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  const marginLeft = getComputedMargin(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  };\n};\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ top: number, right: number, bottom: number, left: number }} position\n */\nconst getPosition = node => {\n  const {\n    yogaNode\n  } = node;\n  return {\n    top: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedTop()) || 0,\n    right: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedRight()) || 0,\n    bottom: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedBottom()) || 0,\n    left: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedLeft()) || 0\n  };\n};\n\nconst DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0\n};\n\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ width: number, height: number }} dimensions\n */\nconst getDimension = node => {\n  const {\n    yogaNode\n  } = node;\n  if (!yogaNode) return DEFAULT_DIMENSION;\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight()\n  };\n};\n\nconst getComputedBorder = (yogaNode, edge) => yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param {Object} node\n * @returns {{ borderTopWidth: number, borderRightWidth: number, borderBottomWidth: number, borderLeftWidth: number }} border widths\n */\nconst getBorderWidth = node => {\n  const {\n    yogaNode\n  } = node;\n  return {\n    borderTopWidth: getComputedBorder(yogaNode, Yoga.Edge.Top),\n    borderRightWidth: getComputedBorder(yogaNode, Yoga.Edge.Right),\n    borderBottomWidth: getComputedBorder(yogaNode, Yoga.Edge.Bottom),\n    borderLeftWidth: getComputedBorder(yogaNode, Yoga.Edge.Left)\n  };\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param {string} value display\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setDisplay = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    yogaNode.setDisplay(value === 'none' ? Yoga.Display.None : Yoga.Display.Flex);\n  }\n  return node;\n};\n\nconst OVERFLOW = {\n  hidden: Yoga.Overflow.Hidden,\n  scroll: Yoga.Overflow.Scroll\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param {string} value overflow value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setOverflow = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const overflow = OVERFLOW[value] || Yoga.Overflow.Visible;\n    yogaNode.setOverflow(overflow);\n  }\n  return node;\n};\n\nconst FLEX_WRAP = {\n  wrap: Yoga.Wrap.Wrap,\n  'wrap-reverse': Yoga.Wrap.WrapReverse\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param {string} value flex wrap value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexWrap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    const flexWrap = FLEX_WRAP[value] || Yoga.Wrap.NoWrap;\n    yogaNode.setFlexWrap(flexWrap);\n  }\n  return node;\n};\n\n/* eslint-disable no-unused-expressions */\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * @typedef {Function} YogaValueSetter\n * @param {any} value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param {string} attr property\n * @param {number} [edge] edge\n * @returns {YogaValueSetter} node instance wrapper\n */\nconst setYogaValue = (attr, edge) => value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const hasEdge = !isNil(edge);\n    const fixedMethod = `set${upperFirst(attr)}`;\n    const autoMethod = `${fixedMethod}Auto`;\n    const percentMethod = `${fixedMethod}Percent`;\n    const percent = matchPercent(value);\n    if (percent && !yogaNode[percentMethod]) {\n      throw new Error(`You can't pass percentage values to ${attr} property`);\n    }\n    if (percent) {\n      if (hasEdge) {\n        var _yogaNode$percentMeth;\n        (_yogaNode$percentMeth = yogaNode[percentMethod]) === null || _yogaNode$percentMeth === void 0 ? void 0 : _yogaNode$percentMeth.call(yogaNode, edge, percent.value);\n      } else {\n        var _yogaNode$percentMeth2;\n        (_yogaNode$percentMeth2 = yogaNode[percentMethod]) === null || _yogaNode$percentMeth2 === void 0 ? void 0 : _yogaNode$percentMeth2.call(yogaNode, percent.value);\n      }\n    } else if (value === 'auto') {\n      if (hasEdge) {\n        var _yogaNode$autoMethod;\n        (_yogaNode$autoMethod = yogaNode[autoMethod]) === null || _yogaNode$autoMethod === void 0 ? void 0 : _yogaNode$autoMethod.call(yogaNode, edge);\n      } else {\n        var _yogaNode$autoMethod2;\n        (_yogaNode$autoMethod2 = yogaNode[autoMethod]) === null || _yogaNode$autoMethod2 === void 0 ? void 0 : _yogaNode$autoMethod2.call(yogaNode);\n      }\n    } else if (hasEdge) {\n      var _yogaNode$fixedMethod;\n      (_yogaNode$fixedMethod = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod === void 0 ? void 0 : _yogaNode$fixedMethod.call(yogaNode, edge, value);\n    } else {\n      var _yogaNode$fixedMethod2;\n      (_yogaNode$fixedMethod2 = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod2 === void 0 ? void 0 : _yogaNode$fixedMethod2.call(yogaNode, value);\n    }\n  }\n  return node;\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param {number} value flex grow value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexGrow = value => node => {\n  return setYogaValue('flexGrow')(value || 0)(node);\n};\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param {number} flex basis value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\n\nconst ALIGN = {\n  'flex-start': Yoga.Align.FlexStart,\n  center: Yoga.Align.Center,\n  'flex-end': Yoga.Align.FlexEnd,\n  stretch: Yoga.Align.Stretch,\n  baseline: Yoga.Align.Baseline,\n  'space-between': Yoga.Align.SpaceBetween,\n  'space-around': Yoga.Align.SpaceAround,\n  'space-evenly': Yoga.Align.SpaceEvenly\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * @typedef {Function} AlignSetter\n * @param {string} value align value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\n\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param {string} attr specific align property\n * @returns {AlignSetter} align setter\n */\nconst setAlign = attr => value => node => {\n  const {\n    yogaNode\n  } = node;\n  const defaultValue = attr === 'items' ? Yoga.Align.Stretch : Yoga.Align.Auto;\n  if (yogaNode) {\n    const align = ALIGN[value] || defaultValue;\n    yogaNode[`setAlign${upperFirst(attr)}`](align);\n  }\n  return node;\n};\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param {string} align value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setAlignSelf = setAlign('self');\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param {string} align value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setAlignItems = setAlign('items');\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param {number} value flex shrink value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexShrink = value => node => {\n  return setYogaValue('flexShrink')(value || 1)(node);\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param {number} value ratio\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setAspectRatio = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setAspectRatio(value);\n  }\n  return node;\n};\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param {string} align value\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setAlignContent = setAlign('content');\n\nconst POSITION = {\n  absolute: Yoga.PositionType.Absolute,\n  relative: Yoga.PositionType.Relative,\n  static: Yoga.PositionType.Static\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param {string} value position position type\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setPositionType = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setPositionType(POSITION[value]);\n  }\n  return node;\n};\n\nconst FLEX_DIRECTIONS = {\n  row: Yoga.FlexDirection.Row,\n  'row-reverse': Yoga.FlexDirection.RowReverse,\n  'column-reverse': Yoga.FlexDirection.ColumnReverse\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param {string} value flex direction value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setFlexDirection = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    const flexDirection = FLEX_DIRECTIONS[value] || Yoga.FlexDirection.Column;\n    yogaNode.setFlexDirection(flexDirection);\n  }\n  return node;\n};\n\nconst JUSTIFY_CONTENT = {\n  center: Yoga.Justify.Center,\n  'flex-end': Yoga.Justify.FlexEnd,\n  'space-between': Yoga.Justify.SpaceBetween,\n  'space-around': Yoga.Justify.SpaceAround,\n  'space-evenly': Yoga.Justify.SpaceEvenly\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param {string} value justify content value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setJustifyContent = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const justifyContent = JUSTIFY_CONTENT[value] || Yoga.Justify.FlexStart;\n    yogaNode.setJustifyContent(justifyContent);\n  }\n  return node;\n};\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param {number} margin margin top\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginTop = setYogaValue('margin', Yoga.Edge.Top);\n\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param {number} margin margin right\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginRight = setYogaValue('margin', Yoga.Edge.Right);\n\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param {number} margin margin bottom\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginBottom = setYogaValue('margin', Yoga.Edge.Bottom);\n\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param {number} margin margin left\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setMarginLeft = setYogaValue('margin', Yoga.Edge.Left);\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param {number} padding padding top\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingTop = setYogaValue('padding', Yoga.Edge.Top);\n\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param {number} padding padding right\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingRight = setYogaValue('padding', Yoga.Edge.Right);\n\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param {number} padding padding bottom\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingBottom = setYogaValue('padding', Yoga.Edge.Bottom);\n\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param {number} padding padding left\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPaddingLeft = setYogaValue('padding', Yoga.Edge.Left);\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param {number} border border top width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderTop = setYogaValue('border', Yoga.Edge.Top);\n\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param {number} border border right width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderRight = setYogaValue('border', Yoga.Edge.Right);\n\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param {number} border border bottom width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderBottom = setYogaValue('border', Yoga.Edge.Bottom);\n\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param {number} border border left width\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setBorderLeft = setYogaValue('border', Yoga.Edge.Left);\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param {number} position position top\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionTop = setYogaValue('position', Yoga.Edge.Top);\n\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param {number} position position right\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionRight = setYogaValue('position', Yoga.Edge.Right);\n\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param {number} position position bottom\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionBottom = setYogaValue('position', Yoga.Edge.Bottom);\n\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param {number} position position left\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\nconst setPositionLeft = setYogaValue('position', Yoga.Edge.Left);\n\n/**\n * Set width to node's Yoga instance\n *\n * @param {number} width\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setWidth = setYogaValue('width');\n\n/**\n * Set min width to node's Yoga instance\n *\n * @param {number} min width\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMinWidth = setYogaValue('minWidth');\n\n/**\n * Set max width to node's Yoga instance\n *\n * @param {number} max width\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMaxWidth = setYogaValue('maxWidth');\n\n/**\n * Set height to node's Yoga instance\n *\n * @param {number} height\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setHeight = setYogaValue('height');\n\n/**\n * Set min height to node's Yoga instance\n *\n * @param {number} min height\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMinHeight = setYogaValue('minHeight');\n\n/**\n * Set max height to node's Yoga instance\n *\n * @param {number} max height\n * @param {Object} node instance\n * @returns {Object} node instance\n */\nconst setMaxHeight = setYogaValue('maxHeight');\n\n/**\n * @typedef {Function} NodeInstanceWrapper\n * @param {Object} node node instance\n * @returns {Object} node instance\n */\n\n/**\n * Set rowGap value to node's Yoga instance\n *\n * @param {number} value gap value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setRowGap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setGap(Yoga.Gutter.Row, value);\n  }\n  return node;\n};\n\n/**\n * Set columnGap value to node's Yoga instance\n *\n * @param {number} value gap value\n * @returns {NodeInstanceWrapper} node instance wrapper\n */\nconst setColumnGap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setGap(Yoga.Gutter.Column, value);\n  }\n  return node;\n};\n\nconst getAspectRatio = viewbox => {\n  if (!viewbox) return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n\n/**\n * @typedef {Function} MeasureSvg\n * @param {number} width\n * @param {number} widthMode\n * @param {number} height\n * @param {number} heightMode\n * @returns {{ width: number, height: number }} svg width and height\n */\n\n/**\n * Yoga svg measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureSvg} measure svg\n */\nconst measureCanvas$1 = (page, node) => (width, widthMode, height, heightMode) => {\n  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n  if (widthMode === Yoga.MeasureMode.Exactly || widthMode === Yoga.MeasureMode.AtMost) {\n    return {\n      width,\n      height: width / aspectRatio\n    };\n  }\n  if (heightMode === Yoga.MeasureMode.Exactly) {\n    return {\n      width: height * aspectRatio\n    };\n  }\n  return {};\n};\n\n/**\n * Get lines width (if any)\n *\n * @param {Object} node\n * @returns {number} lines width\n */\nconst linesWidth = node => {\n  if (!node.lines) return 0;\n  return Math.max(0, ...node.lines.map(line => line.xAdvance));\n};\n\n/**\n * Get lines height (if any)\n *\n * @param {Object} node\n * @returns {number} lines height\n */\nconst linesHeight = node => {\n  if (!node.lines) return -1;\n  return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\n\n/* eslint-disable no-param-reassign */\n\nconst ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n\n/**\n * @typedef {Function} MeasureText\n * @param {number} width\n * @param {number} widthMode\n * @param {number} height\n * @returns {{ width: number, height: number }} text width and height\n */\n\n/**\n * Yoga text measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Object} fontStore\n * @returns {MeasureText} measure text function\n */\nconst measureText = (page, node, fontStore) => (width, widthMode, height) => {\n  if (widthMode === Yoga.MeasureMode.Exactly) {\n    if (!node.lines) node.lines = layoutText(node, width, height, fontStore);\n    return {\n      height: linesHeight(node)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.AtMost) {\n    var _node$style;\n    const alignFactor = ALIGNMENT_FACTORS[(_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.textAlign] || 0;\n    if (!node.lines) {\n      node.lines = layoutText(node, width, height, fontStore);\n      node.alignOffset = (width - linesWidth(node)) * alignFactor; // Compensate align in variable width containers\n    }\n    return {\n      height: linesHeight(node),\n      width: Math.min(width, linesWidth(node))\n    };\n  }\n  return {};\n};\n\n/**\n * Get image ratio\n *\n * @param {Object} node image node\n * @returns {number} image ratio\n */\nconst getRatio = node => {\n  var _node$image;\n  return (_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data ? node.image.width / node.image.height : 1;\n};\n\n/**\n * Checks if page has auto height\n *\n * @param {Object} page\n * @returns {boolean} is page height auto\n */\nconst isHeightAuto = page => {\n  var _page$box;\n  return isNil((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.height);\n};\n\nconst SAFETY_HEIGHT$1 = 10;\n\n/**\n * @typedef {Function} MeasureImage\n * @param {number} width\n * @param {number} widthMode\n * @param {number} height\n * @param {number} heightMode\n * @returns {{ width: number, height: number }} image width and height\n */\n\n/**\n * Yoga image measure function\n *\n * @param {Object} page page\n * @param {Object} node node\n * @returns {MeasureImage} measure image\n */\nconst measureImage = (page, node) => (width, widthMode, height, heightMode) => {\n  const imageRatio = getRatio(node);\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;\n\n  // Skip measure if image data not present yet\n  if (!node.image) return {\n    width: 0,\n    height: 0\n  };\n  if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.Undefined) {\n    const scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(pageArea, scaledHeight)\n    };\n  }\n  if (heightMode === Yoga.MeasureMode.Exactly && (widthMode === Yoga.MeasureMode.AtMost || widthMode === Yoga.MeasureMode.Undefined)) {\n    return {\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.AtMost) {\n    const scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(height, pageArea, scaledHeight)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.AtMost && heightMode === Yoga.MeasureMode.AtMost) {\n    if (imageRatio > 1) {\n      return {\n        width,\n        height: Math.min(width / imageRatio, height)\n      };\n    }\n    return {\n      height,\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n  return {\n    height,\n    width\n  };\n};\n\n/* eslint-disable no-param-reassign */\n\nconst SAFETY_HEIGHT = 10;\nconst getMax = values => Math.max(-Infinity, ...values);\n\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n  const ctx = {};\n  const points = [];\n  const nil = () => ctx;\n  const addPoint = (x, y) => points.push([x, y]);\n  const moveTo = function () {\n    addPoint(...arguments);\n    return ctx;\n  };\n  const rect = (x, y, w, h) => {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n  const ellipse = (x, y, rx, ry) => {\n    ry = ry || rx;\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n    return ctx;\n  };\n  const polygon = function () {\n    points.push(...arguments);\n    return ctx;\n  };\n\n  // Change dimensions\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect;\n\n  // To be implemented\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil;\n\n  // These don't change dimensions\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n  ctx.getWidth = () => getMax(points.map(p => p[0]));\n  ctx.getHeight = () => getMax(points.map(p => p[1]));\n  return ctx;\n};\n\n/**\n * @typedef {Function} MeasureCanvas\n * @returns {{ width: number, height: number }} canvas width and height\n */\n\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureCanvas} measure canvas\n */\nconst measureCanvas = (page, node) => () => {\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;\n  const ctx = measureCtx();\n  node.props.paint(ctx);\n  const width = ctx.getWidth();\n  const height = Math.min(pageArea, ctx.getHeight());\n  return {\n    width,\n    height\n  };\n};\n\nconst isType$1 = type => node => node.type === type;\nconst isSvg = isType$1(P.Svg);\nconst isText$2 = isType$1(P.Text);\nconst isNote = isType$1(P.Note);\nconst isPage = isType$1(P.Page);\nconst isImage = isType$1(P.Image);\nconst isCanvas = isType$1(P.Canvas);\nconst isTextInstance$1 = isType$1(P.TextInstance);\nconst setNodeHeight = node => {\n  const value = isPage(node) ? node.box.height : node.style.height;\n  return setHeight(value);\n};\n\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst setYogaValues = node => {\n  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);\n};\n\n/**\n * @typedef {Function} InsertYogaNodes\n * @param {Object} child child node\n * @returns {Object} node\n */\n\n/**\n * Inserts child into parent' yoga node\n *\n * @param {Object} parent parent\n * @returns {InsertYogaNodes} insert yoga nodes\n */\nconst insertYogaNodes = parent => child => {\n  parent.insertChild(child.yogaNode, parent.getChildCount());\n  return child;\n};\nconst setMeasureFunc = (node, page, fontStore) => {\n  const {\n    yogaNode\n  } = node;\n  if (isText$2(node)) {\n    yogaNode.setMeasureFunc(measureText(page, node, fontStore));\n  }\n  if (isImage(node)) {\n    yogaNode.setMeasureFunc(measureImage(page, node));\n  }\n  if (isCanvas(node)) {\n    yogaNode.setMeasureFunc(measureCanvas(page, node));\n  }\n  if (isSvg(node)) {\n    yogaNode.setMeasureFunc(measureCanvas$1(page, node));\n  }\n  return node;\n};\nconst isLayoutElement = node => !isText$2(node) && !isNote(node) && !isSvg(node);\n\n/**\n * @typedef {Function} CreateYogaNodes\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @returns {CreateYogaNodes} create yoga nodes\n */\nconst createYogaNodes = (page, fontStore, yoga) => node => {\n  const yogaNode = yoga.node.create();\n  const result = Object.assign({}, node, {\n    yogaNode\n  });\n  setYogaValues(result);\n  if (isLayoutElement(node) && node.children) {\n    const resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore, yoga));\n    result.children = node.children.map(resolveChild);\n  }\n  setMeasureFunc(result, page, fontStore);\n  return result;\n};\n\n/**\n * Performs yoga calculation\n *\n * @param {Object} page page node\n * @returns {Object} page node\n */\nconst calculateLayout = page => {\n  page.yogaNode.calculateLayout();\n  return page;\n};\n\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param {Object} node\n * @returns {Object} node with box data\n */\nconst persistDimensions = node => {\n  if (isTextInstance$1(node)) return node;\n  const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));\n  const newNode = Object.assign({}, node, {\n    box\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(persistDimensions);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Removes yoga node from document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nconst destroyYogaNodes = node => {\n  const newNode = Object.assign({}, node);\n  delete newNode.yogaNode;\n  if (!node.children) return newNode;\n  const children = node.children.map(destroyYogaNodes);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Free yoga node from document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nconst freeYogaNodes = node => {\n  if (node.yogaNode) node.yogaNode.freeRecursive();\n  return node;\n};\n\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param {Object} page object\n * @returns {Object} page object with correct 'box' layout attributes\n */\nconst resolvePageDimensions = (page, fontStore, yoga) => {\n  if (isNil(page)) return null;\n  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore, yoga))(page);\n};\n\n/**\n * Calculates root object layout using Yoga.\n *\n * @param {Object} node root object\n * @param {Object} fontStore font store\n * @returns {Object} root object with correct 'box' layout attributes\n */\nconst resolveDimensions = (node, fontStore) => {\n  if (!node.children) return node;\n  const resolveChild = child => resolvePageDimensions(child, fontStore, node.yoga);\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\n/* eslint-disable no-use-before-define */\n/* eslint-disable no-continue */\n/* eslint-disable prefer-destructuring */\n\nconst isText$1 = node => node.type === P.Text;\n\n// Prevent splitting elements by low decimal numbers\nconst SAFETY_THRESHOLD = 0.001;\nconst assingChildren = (children, node) => Object.assign({}, node, {\n  children\n});\nconst getTop = node => {\n  var _node$box;\n  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;\n};\nconst allFixed = nodes => nodes.every(isFixed);\nconst isDynamic = node => {\n  var _node$props;\n  return !isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.render);\n};\nconst relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);\nconst warnUnavailableSpace = node => {\n  console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);\n};\nconst splitNodes = (height, contentArea, nodes) => {\n  const currentChildren = [];\n  const nextChildren = [];\n  for (let i = 0; i < nodes.length; i += 1) {\n    const child = nodes[i];\n    const futureNodes = nodes.slice(i + 1);\n    const futureFixedNodes = futureNodes.filter(isFixed);\n    const nodeTop = getTop(child);\n    const nodeHeight = child.box.height;\n    const isOutside = height <= nodeTop;\n    const shouldBreak$1 = shouldBreak(child, futureNodes, height);\n    const shouldSplit = height + SAFETY_THRESHOLD < nodeTop + nodeHeight;\n    const canWrap = getWrap(child);\n    const fitsInsidePage = nodeHeight <= contentArea;\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n    if (isOutside) {\n      const box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      const next = Object.assign({}, child, {\n        box\n      });\n      nextChildren.push(next);\n      continue;\n    }\n    if (!fitsInsidePage && !canWrap) {\n      currentChildren.push(child);\n      nextChildren.push(...futureNodes);\n      warnUnavailableSpace(child);\n      break;\n    }\n    if (shouldBreak$1) {\n      const box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      const props = Object.assign({}, child.props, {\n        wrap: true,\n        break: false\n      });\n      const next = Object.assign({}, child, {\n        box,\n        props\n      });\n      currentChildren.push(...futureFixedNodes);\n      nextChildren.push(next, ...futureNodes);\n      break;\n    }\n    if (shouldSplit) {\n      const [currentChild, nextChild] = split(child, height, contentArea);\n\n      // All children are moved to the next page, it doesn't make sense to show the parent on the current page\n      if (child.children.length > 0 && currentChild.children.length === 0) {\n        // But if the current page is empty then we can just include the parent on the current page\n        if (currentChildren.length === 0) {\n          currentChildren.push(child, ...futureFixedNodes);\n          nextChildren.push(...futureNodes);\n        } else {\n          const box = Object.assign({}, child.box, {\n            top: child.box.top - height\n          });\n          const next = Object.assign({}, child, {\n            box\n          });\n          currentChildren.push(...futureFixedNodes);\n          nextChildren.push(next, ...futureNodes);\n        }\n        break;\n      }\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n      continue;\n    }\n    currentChildren.push(child);\n  }\n  return [currentChildren, nextChildren];\n};\nconst splitChildren = (height, contentArea, node) => {\n  const children = node.children || [];\n  const availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, contentArea, children);\n};\nconst splitView = (node, height, contentArea) => {\n  const [currentNode, nextNode] = splitNode(node, height);\n  const [currentChilds, nextChildren] = splitChildren(height, contentArea, node);\n  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];\n};\nconst split = (node, height, contentArea) => isText$1(node) ? splitText(node, height) : splitView(node, height, contentArea);\nconst shouldResolveDynamicNodes = node => {\n  const children = node.children || [];\n  return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\nconst resolveDynamicNodes = (props, node) => {\n  const isNodeDynamic = isDynamic(node);\n\n  // Call render prop on dynamic nodes and append result to children\n  const resolveChildren = function (children) {\n    if (children === void 0) {\n      children = [];\n    }\n    if (isNodeDynamic) {\n      const res = node.props.render(props);\n      return createInstances(res).filter(Boolean).map(n => resolveDynamicNodes(props, n));\n    }\n    return children.map(c => resolveDynamicNodes(props, c));\n  };\n\n  // We reset dynamic text box so it can be computed again later on\n  const resetHeight = isNodeDynamic && isText$1(node);\n  const box = resetHeight ? {\n    ...node.box,\n    height: 0\n  } : node.box;\n  const children = resolveChildren(node.children);\n  const lines = isNodeDynamic ? null : node.lines;\n  return Object.assign({}, node, {\n    box,\n    lines,\n    children\n  });\n};\nconst resolveDynamicPage = (props, page, fontStore, yoga) => {\n  if (shouldResolveDynamicNodes(page)) {\n    const resolvedPage = resolveDynamicNodes(props, page);\n    return relayoutPage(resolvedPage, fontStore, yoga);\n  }\n  return page;\n};\nconst splitPage = (page, pageNumber, fontStore, yoga) => {\n  const wrapArea = getWrapArea(page);\n  const contentArea = getContentArea(page);\n  const dynamicPage = resolveDynamicPage({\n    pageNumber\n  }, page, fontStore, yoga);\n  const height = page.style.height;\n  const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);\n  const relayout = node => relayoutPage(node, fontStore, yoga);\n  const currentBox = {\n    ...page.box,\n    height\n  };\n  const currentPage = relayout(Object.assign({}, page, {\n    box: currentBox,\n    children: currentChilds\n  }));\n  if (nextChilds.length === 0 || allFixed(nextChilds)) return [currentPage, null];\n  const nextBox = omit('height', page.box);\n  const nextProps = omit('bookmark', page.props);\n  const nextPage = relayout(Object.assign({}, page, {\n    props: nextProps,\n    box: nextBox,\n    children: nextChilds\n  }));\n  return [currentPage, nextPage];\n};\nconst resolvePageIndices = (fontStore, yoga, page, pageNumber, pages) => {\n  const totalPages = pages.length;\n  const props = {\n    totalPages,\n    pageNumber: pageNumber + 1,\n    subPageNumber: page.subPageNumber + 1,\n    subPageTotalPages: page.subPageTotalPages\n  };\n  return resolveDynamicPage(props, page, fontStore, yoga);\n};\nconst assocSubPageData = subpages => {\n  return subpages.map((page, i) => ({\n    ...page,\n    subPageNumber: i,\n    subPageTotalPages: subpages.length\n  }));\n};\nconst dissocSubPageData = page => {\n  return omit(['subPageNumber', 'subPageTotalPages'], page);\n};\nconst paginate = (page, pageNumber, fontStore, yoga) => {\n  var _page$props;\n  if (!page) return [];\n  if (((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.wrap) === false) return [page];\n  let splittedPage = splitPage(page, pageNumber, fontStore, yoga);\n  const pages = [splittedPage[0]];\n  let nextPage = splittedPage[1];\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore, yoga);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n  return pages;\n};\n\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param {Object} doc node\n * @param {Object} fontStore font store\n * @returns {Object} layout node\n */\nconst resolvePagination = (doc, fontStore) => {\n  let pages = [];\n  let pageNumber = 1;\n  for (let i = 0; i < doc.children.length; i += 1) {\n    const page = doc.children[i];\n    let subpages = paginate(page, pageNumber, fontStore, doc.yoga);\n    subpages = assocSubPageData(subpages);\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n  pages = pages.map(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return dissocSubPageData(resolvePageIndices(fontStore, doc.yoga, ...args));\n  });\n  return assingChildren(pages, doc);\n};\n\n/**\n * @typedef {Function} ResolvePageHorizontalPadding\n * @param {string} value padding value\n * @returns {Object} translated padding value\n */\n\n/**\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param {Object} container page container\n * @returns {ResolvePageHorizontalPadding} resolve page horizontal padding\n */\nconst resolvePageHorizontalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.width : value;\n};\n\n/**\n * @typedef {Function} ResolvePageVerticalPadding\n * @param {string} padding value\n * @returns {Object} translated padding value\n */\n\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param {Object} container page container\n * @returns {ResolvePageVerticalPadding} resolve page vertical padding\n */\nconst resolvePageVerticalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.height : value;\n};\n\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param {Object} page\n * @returns {Object} page with fixed paddings\n */\nconst resolvePagePaddings = page => {\n  const container = page.style;\n  const style = evolve({\n    paddingTop: resolvePageVerticalPadding(container),\n    paddingLeft: resolvePageHorizontalPadding(container),\n    paddingRight: resolvePageHorizontalPadding(container),\n    paddingBottom: resolvePageVerticalPadding(container)\n  }, page.style);\n  return Object.assign({}, page, {\n    style\n  });\n};\n\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param {Object} root document root\n * @returns {Object} document root with translated page paddings\n */\nconst resolvePagesPaddings = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePagePaddings);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\n/**\n * @typedef {Function} ResolveRadius\n * @param {string | number} value border radius value\n * @returns {number} resolved radius value\n */\n\n/**\n *\n * @param {{ width: number, height: number }} container width and height\n * @returns {ResolveRadius} resolve radius function\n */\nconst resolveRadius = container => value => {\n  if (!value) return undefined;\n  const match = matchPercent(value);\n  return match ? match.percent * Math.min(container.width, container.height) : value;\n};\n\n/**\n * Transforms percent border radius into fixed values\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolvePercentRadius = node => {\n  const style = evolve({\n    borderTopLeftRadius: resolveRadius(node.box),\n    borderTopRightRadius: resolveRadius(node.box),\n    borderBottomRightRadius: resolveRadius(node.box),\n    borderBottomLeftRadius: resolveRadius(node.box)\n  }, node.style || {});\n  const newNode = Object.assign({}, node, {\n    style\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(resolvePercentRadius);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Transform percent height into fixed\n *\n * @param {number} height\n * @returns {number} height\n */\nconst transformHeight = (pageArea, height) => {\n  const match = matchPercent(height);\n  return match ? match.percent * pageArea : height;\n};\n\n/**\n * Get page area (height minus paddings)\n *\n * @param {Object} page\n * @returns {number} page area\n */\nconst getPageArea = page => {\n  var _page$style, _page$style2;\n  const pageHeight = page.style.height;\n  const pagePaddingTop = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.paddingTop) || 0;\n  const pagePaddingBottom = ((_page$style2 = page.style) === null || _page$style2 === void 0 ? void 0 : _page$style2.paddingBottom) || 0;\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n\n/**\n * Transform node percent height to fixed\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {Object} transformed node\n */\nconst resolveNodePercentHeight = (page, node) => {\n  var _page$style3, _node$style;\n  if (isNil((_page$style3 = page.style) === null || _page$style3 === void 0 ? void 0 : _page$style3.height)) return node;\n  if (isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height)) return node;\n  const pageArea = getPageArea(page);\n  const height = transformHeight(pageArea, node.style.height);\n  const style = Object.assign({}, node.style, {\n    height\n  });\n  return Object.assign({}, node, {\n    style\n  });\n};\n\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param {Object} page\n * @returns {Object} transformed page\n */\nconst resolvePagePercentHeight = page => {\n  if (!page.children) return page;\n  const resolveChild = child => resolveNodePercentHeight(page, child);\n  const children = page.children.map(resolveChild);\n  return Object.assign({}, page, {\n    children\n  });\n};\n\n/**\n * Transform all page immediate children with percent height to fixed.\n * This is needed for computing correct dimensions on pre-pagination layout.\n *\n * @param {Object} root document root\n * @returns {Object} transformed document root\n */\nconst resolvePercentHeight = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePagePercentHeight);\n  return Object.assign({}, root, {\n    children\n  });\n};\n\nconst isType = type => node => node.type === type;\nconst isLink = isType(P.Link);\nconst isText = isType(P.Text);\nconst isTextInstance = isType(P.TextInstance);\n\n/**\n * Checks if node has render prop\n *\n * @param {Object} node\n * @returns {boolean} has render prop?\n */\nconst hasRenderProp = node => {\n  var _node$props;\n  return !!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.render);\n};\n\n/**\n * Checks if node is text type (Text or TextInstance)\n *\n * @param {Object} node\n * @returns {boolean} are all children text instances?\n */\nconst isTextType = node => isText(node) || isTextInstance(node);\n\n/**\n * Checks if is tet link that needs to be wrapped in Text\n *\n * @param {Object} node\n * @returns {boolean} are all children text instances?\n */\nconst isTextLink = node => {\n  const children = node.children || [];\n\n  // Text string inside a Link\n  if (children.every(isTextInstance)) return true;\n\n  // Text node inside a Link\n  if (children.every(isText)) return false;\n  return children.every(isTextType);\n};\n\n/**\n * Wraps node children inside Text node\n *\n * @param {Object} node\n * @returns {boolean} node with intermediate Text child\n */\nconst wrapText = node => {\n  const textElement = {\n    type: P.Text,\n    props: {},\n    style: {},\n    box: {},\n    children: node.children\n  };\n  return Object.assign({}, node, {\n    children: [textElement]\n  });\n};\nconst transformLink = node => {\n  if (!isLink(node)) return node;\n\n  // If has render prop substitute the instance by a Text, that will\n  // ultimately render the inline Link via the textkit PDF renderer.\n  if (hasRenderProp(node)) return Object.assign({}, node, {\n    type: P.Text\n  });\n\n  // If is a text link (either contains Text or TextInstalce), wrap it\n  // inside a Text element so styles are applied correctly\n\n  if (isTextLink(node)) return wrapText(node);\n  return node;\n};\n\n/**\n * Transforms Link layout to correctly render text and dynamic rendered links\n *\n * @param {Object} node\n * @returns {Object} node with link substitution\n */\nconst resolveLinkSubstitution = node => {\n  if (!node.children) return node;\n  const resolveChild = compose(transformLink, resolveLinkSubstitution);\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\n\nconst layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);\n\nexport { layout as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}