{"ast":null,"code":"import { compose, castArray, matchPercent } from '@react-pdf/fns';\nimport parse$1 from 'postcss-value-parser/lib/parse.js';\nimport parseUnit from 'postcss-value-parser/lib/unit.js';\nimport hlsToHex from 'hsl-to-hex';\nimport colorString from 'color-string';\nimport matchMedia from 'media-engine';\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\n\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\nconst flexDefaults = [1, 1, 0];\n/**\n * @type {(number | 'auto')[]}\n */\nconst flexAuto = [1, 1, 'auto'];\nconst expandFlex = (key, value) => {\n  /**\n   * @type {(number | 'auto')[]}\n   */\n  let defaults = flexDefaults;\n  let matches = [];\n  if (value === 'auto') {\n    defaults = flexAuto;\n  } else {\n    matches = `${value}`.split(' ');\n  }\n  const flexGrow = matches[0] || defaults[0];\n  const flexShrink = matches[1] || defaults[1];\n  const flexBasis = matches[2] || defaults[2];\n  return {\n    flexGrow,\n    flexShrink,\n    flexBasis\n  };\n};\n\n/* eslint-disable no-plusplus */\n// This file is ran directly with Node - needs to have .js extension\n// eslint-disable-next-line import/extensions\nconst BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\nconst logError = (style, value) => {\n  console.error(`\n    @react-pdf/stylesheet parsing error:\n\n    ${style}: ${value},\n    ${' '.repeat(style.length + 2)}^\n    Unsupported ${style} value format\n  `);\n};\n\n/**\n * @param {Object} options\n * @param {Function} [options.expandsTo]\n * @param {number} [options.maxValues]\n * @param {boolean} [options.autoSupported]\n */\nconst expandBoxModel = function (_temp) {\n  let {\n    expandsTo,\n    maxValues = 1,\n    autoSupported = false\n  } = _temp === void 0 ? {} : _temp;\n  return (model, value) => {\n    const nodes = parse$1(`${value}`);\n    const parts = [];\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      // value contains `calc`, `url` or other css function\n      // `,`, `/` or strings that unsupported by margin and padding\n      if (node.type === 'function' || node.type === 'string' || node.type === 'div') {\n        logError(model, value);\n        return {};\n      }\n      if (node.type === 'word') {\n        if (node.value === 'auto' && autoSupported) {\n          parts.push(node.value);\n        } else {\n          const result = parseUnit(node.value);\n\n          // when unit isn't specified this condition is true\n          if (result && BOX_MODEL_UNITS.includes(result.unit)) {\n            parts.push(node.value);\n          } else {\n            logError(model, value);\n            return {};\n          }\n        }\n      }\n    }\n\n    // checks that we have enough parsed values\n    if (parts.length > maxValues) {\n      logError(model, value);\n      return {};\n    }\n    const first = parts[0];\n    if (expandsTo) {\n      const second = parts[1] || parts[0];\n      const third = parts[2] || parts[0];\n      const fourth = parts[3] || parts[1] || parts[0];\n      return expandsTo({\n        first,\n        second,\n        third,\n        fourth\n      });\n    }\n    return {\n      [model]: first\n    };\n  };\n};\nconst processMargin = expandBoxModel({\n  expandsTo: _ref => {\n    let {\n      first,\n      second,\n      third,\n      fourth\n    } = _ref;\n    return {\n      marginTop: first,\n      marginRight: second,\n      marginBottom: third,\n      marginLeft: fourth\n    };\n  },\n  maxValues: 4,\n  autoSupported: true\n});\nconst processMarginVertical = expandBoxModel({\n  expandsTo: _ref2 => {\n    let {\n      first,\n      second\n    } = _ref2;\n    return {\n      marginTop: first,\n      marginBottom: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginHorizontal = expandBoxModel({\n  expandsTo: _ref3 => {\n    let {\n      first,\n      second\n    } = _ref3;\n    return {\n      marginRight: first,\n      marginLeft: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginSingle = expandBoxModel({\n  autoSupported: true\n});\nconst BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\\s(\\S+)\\s(.+)/;\nconst matchBorderShorthand = value => value.match(BORDER_SHORTHAND_REGEX) || [];\nconst expandBorders = (key, value) => {\n  const match = matchBorderShorthand(`${value}`);\n  if (match) {\n    const color = match[5] || value;\n    const style = match[4] || value;\n    const width = match[1] || value;\n    if (key.match(/(Top|Right|Bottom|Left)$/)) {\n      return {\n        [`${key}Color`]: color,\n        [`${key}Style`]: style,\n        [`${key}Width`]: width\n      };\n    }\n    if (key.match(/Color$/)) {\n      return {\n        borderTopColor: color,\n        borderRightColor: color,\n        borderBottomColor: color,\n        borderLeftColor: color\n      };\n    }\n    if (key.match(/Style$/)) {\n      return {\n        borderTopStyle: style,\n        borderRightStyle: style,\n        borderBottomStyle: style,\n        borderLeftStyle: style\n      };\n    }\n    if (key.match(/Width$/)) {\n      return {\n        borderTopWidth: width,\n        borderRightWidth: width,\n        borderBottomWidth: width,\n        borderLeftWidth: width\n      };\n    }\n    if (key.match(/Radius$/)) {\n      return {\n        borderTopLeftRadius: value,\n        borderTopRightRadius: value,\n        borderBottomRightRadius: value,\n        borderBottomLeftRadius: value\n      };\n    }\n    return {\n      borderTopColor: color,\n      borderTopStyle: style,\n      borderTopWidth: width,\n      borderRightColor: color,\n      borderRightStyle: style,\n      borderRightWidth: width,\n      borderBottomColor: color,\n      borderBottomStyle: style,\n      borderBottomWidth: width,\n      borderLeftColor: color,\n      borderLeftStyle: style,\n      borderLeftWidth: width\n    };\n  }\n  return value;\n};\nconst processPadding = expandBoxModel({\n  expandsTo: _ref => {\n    let {\n      first,\n      second,\n      third,\n      fourth\n    } = _ref;\n    return {\n      paddingTop: first,\n      paddingRight: second,\n      paddingBottom: third,\n      paddingLeft: fourth\n    };\n  },\n  maxValues: 4\n});\nconst processPaddingVertical = expandBoxModel({\n  expandsTo: _ref2 => {\n    let {\n      first,\n      second\n    } = _ref2;\n    return {\n      paddingTop: first,\n      paddingBottom: second\n    };\n  },\n  maxValues: 2\n});\nconst processPaddingHorizontal = expandBoxModel({\n  expandsTo: _ref3 => {\n    let {\n      first,\n      second\n    } = _ref3;\n    return {\n      paddingRight: first,\n      paddingLeft: second\n    };\n  },\n  maxValues: 2\n});\nconst processPaddingSingle = expandBoxModel();\nconst expandObjectPosition = (key, value) => {\n  const match = `${value}`.split(' ');\n  return {\n    objectPositionX: (match === null || match === void 0 ? void 0 : match[0]) || value,\n    objectPositionY: (match === null || match === void 0 ? void 0 : match[1]) || value\n  };\n};\nconst Y_AXIS_SHORTHANDS = {\n  top: true,\n  bottom: true\n};\nconst sortTransformOriginPair = (a, b) => {\n  if (Y_AXIS_SHORTHANDS[a]) return 1;\n  if (Y_AXIS_SHORTHANDS[b]) return -1;\n  return 0;\n};\nconst getTransformOriginPair = values => {\n  if (!values || values.length === 0) return ['center', 'center'];\n  const pair = values.length === 1 ? [values[0], 'center'] : values;\n  return pair.sort(sortTransformOriginPair);\n};\n\n// Transforms shorthand transformOrigin values\nconst expandTransformOrigin = (key, value) => {\n  const match = `${value}`.split(' ');\n  const pair = getTransformOriginPair(match);\n  return {\n    transformOriginX: pair[0],\n    transformOriginY: pair[1]\n  };\n};\nconst expandGap = (key, value) => {\n  const match = `${value}`.split(' ');\n  return {\n    rowGap: (match === null || match === void 0 ? void 0 : match[0]) || value,\n    columnGap: (match === null || match === void 0 ? void 0 : match[1]) || value\n  };\n};\nconst shorthands = {\n  flex: expandFlex,\n  gap: expandGap,\n  margin: processMargin,\n  marginHorizontal: processMarginHorizontal,\n  marginVertical: processMarginVertical,\n  marginTop: processMarginSingle,\n  marginRight: processMarginSingle,\n  marginBottom: processMarginSingle,\n  marginLeft: processMarginSingle,\n  padding: processPadding,\n  paddingHorizontal: processPaddingHorizontal,\n  paddingVertical: processPaddingVertical,\n  paddingTop: processPaddingSingle,\n  paddingRight: processPaddingSingle,\n  paddingBottom: processPaddingSingle,\n  paddingLeft: processPaddingSingle,\n  border: expandBorders,\n  borderTop: expandBorders,\n  borderRight: expandBorders,\n  borderBottom: expandBorders,\n  borderLeft: expandBorders,\n  borderColor: expandBorders,\n  borderRadius: expandBorders,\n  borderStyle: expandBorders,\n  borderWidth: expandBorders,\n  objectPosition: expandObjectPosition,\n  transformOrigin: expandTransformOrigin\n};\n\n/**\n * Transforms style key-value\n *\n * @param {string} key style key\n * @param {string} value style value\n * @returns {string | Number} transformed style values\n */\nconst expandStyle = (key, value) => {\n  return shorthands[key] ? shorthands[key](key, value) : {\n    [key]: value\n  };\n};\n\n/**\n * Expand the shorthand properties.\n *\n * @param {Object} style object\n * @returns {Object} expanded style object\n */\nconst expand = style => {\n  if (!style) return style;\n  const propsArray = Object.keys(style);\n  const resolvedStyle = {};\n  for (let i = 0; i < propsArray.length; i += 1) {\n    const key = propsArray[i];\n    const value = style[key];\n    const extended = expandStyle(key, value);\n    const keys = Object.keys(extended);\n    for (let j = 0; j < keys.length; j += 1) {\n      const propName = keys[j];\n      const propValue = extended[propName];\n      resolvedStyle[propName] = propValue;\n    }\n  }\n  return resolvedStyle;\n};\n\n/**\n * Remove nil values from array\n *\n * @template T\n * @param {(T | null | undefined)[]} array\n * @returns {T[]} array without nils\n */\nconst compact = array => array.filter(Boolean);\n\n/**\n * Merges style objects array\n *\n * @param {Object[]} styles style objects array\n * @returns {Object} merged style object\n */\nconst mergeStyles = styles => styles.reduce((acc, style) => {\n  const s = Array.isArray(style) ? flatten(style) : style;\n  Object.keys(s).forEach(key => {\n    if (s[key] !== null && s[key] !== undefined) {\n      acc[key] = s[key];\n    }\n  });\n  return acc;\n}, {});\n\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param {Object[]} styles style objects array\n * @returns {Object} flattened style object\n */\nconst flatten = compose(mergeStyles, compact, castArray);\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {string} value scalar value\n * @returns {Object} parsed value\n */\nconst parseValue = value => {\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value,\n    unit: undefined\n  };\n};\n\n/**\n * Transform given scalar value\n *\n * @param {Object} container\n * @param {string} value styles value\n * @returns {Object} transformed value\n */\nconst transformUnit = (container, value) => {\n  const scalar = parseValue(value);\n  const outputDpi = 72;\n  const inputDpi = container.dpi || 72;\n  const mmFactor = 1 / 25.4 * outputDpi;\n  const cmFactor = 1 / 2.54 * outputDpi;\n  switch (scalar.unit) {\n    case 'rem':\n      return scalar.value * (container.remBase || 18);\n    case 'in':\n      return scalar.value * outputDpi;\n    case 'mm':\n      return scalar.value * mmFactor;\n    case 'cm':\n      return scalar.value * cmFactor;\n    case 'vh':\n      return scalar.value * (container.height / 100);\n    case 'vw':\n      return scalar.value * (container.width / 100);\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n    default:\n      return scalar.value;\n  }\n};\nconst isRgb = value => /rgba?/g.test(value);\nconst isHsl = value => /hsla?/g.test(value);\n\n/**\n * Transform rgb color to hexa\n *\n * @param {string} value styles value\n * @returns {Object} transformed value\n */\nconst parseRgb = value => {\n  const rgb = colorString.get.rgb(value);\n  return colorString.to.hex(rgb);\n};\n\n/**\n * Transform Hsl color to hexa\n *\n * @param {string} value styles value\n * @returns {Object} transformed value\n */\nconst parseHsl = value => {\n  const hsl = colorString.get.hsl(value).map(Math.round);\n  const hex = hlsToHex(...hsl);\n  return hex.toUpperCase();\n};\n\n/**\n * Transform given color to hexa\n *\n * @param {string} value styles value\n * @returns {Object} transformed value\n */\nconst transformColor = value => {\n  if (isRgb(value)) return parseRgb(value);\n  if (isHsl(value)) return parseHsl(value);\n  return value;\n};\nconst parse = transformString => {\n  const transforms = transformString.trim().split(/\\)[ ,]|\\)/);\n\n  // Handle \"initial\", \"inherit\", \"unset\".\n  if (transforms.length === 1) {\n    return [[transforms[0], true]];\n  }\n  const parsed = [];\n  for (let i = 0; i < transforms.length; i += 1) {\n    const transform = transforms[i];\n    if (transform) {\n      const [name, rawValue] = transform.split('(');\n      const splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\n      const value = rawValue.split(splitChar).map(val => val.trim());\n      parsed.push({\n        operation: name.trim(),\n        value\n      });\n    }\n  }\n  return parsed;\n};\nconst parseAngle = value => {\n  const unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\n  const [, angle, unit] = unitsRegexp.exec(value);\n  const number = Number.parseFloat(angle);\n  return unit === 'rad' ? number * 180 / Math.PI : number;\n};\nconst normalizeTransformOperation = _ref => {\n  let {\n    operation,\n    value\n  } = _ref;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY = scaleX] = value.map(num => Number.parseFloat(num));\n        return {\n          operation: 'scale',\n          value: [scaleX, scaleY]\n        };\n      }\n    case 'scaleX':\n      {\n        return {\n          operation: 'scale',\n          value: [Number.parseFloat(value), 1]\n        };\n      }\n    case 'scaleY':\n      {\n        return {\n          operation: 'scale',\n          value: [1, Number.parseFloat(value)]\n        };\n      }\n    case 'rotate':\n      {\n        return {\n          operation: 'rotate',\n          value: [parseAngle(value)]\n        };\n      }\n    case 'translate':\n      {\n        return {\n          operation: 'translate',\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n    case 'translateX':\n      {\n        return {\n          operation: 'translate',\n          value: [Number.parseFloat(value), 0]\n        };\n      }\n    case 'translateY':\n      {\n        return {\n          operation: 'translate',\n          value: [0, Number.parseFloat(value)]\n        };\n      }\n    case 'skew':\n      {\n        return {\n          operation: 'skew',\n          value: value.map(parseAngle)\n        };\n      }\n    case 'skewX':\n      {\n        return {\n          operation: 'skew',\n          value: [parseAngle(value), 0]\n        };\n      }\n    case 'skewY':\n      {\n        return {\n          operation: 'skew',\n          value: [0, parseAngle(value)]\n        };\n      }\n    default:\n      {\n        return {\n          operation,\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n  }\n};\nconst normalize = operations => {\n  return operations.map(operation => normalizeTransformOperation(operation));\n};\nconst processTransform = value => {\n  if (typeof value !== 'string') return value;\n  return normalize(parse(value));\n};\nconst FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900\n};\nconst processFontWeight = value => {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  const lv = value.toLowerCase();\n  if (FONT_WEIGHTS[lv]) return FONT_WEIGHTS[lv];\n  return value;\n};\n\n/* eslint-disable no-restricted-globals */\n\nconst processLineHeight = (value, styles) => {\n  if (value === '') return value;\n  const {\n    fontSize = 18\n  } = styles;\n\n  // Percent values: use this number multiplied by the element's font size\n  const {\n    percent\n  } = matchPercent(value) || {};\n  if (percent) return percent * fontSize;\n\n  // Unitless values: use this number multiplied by the element's font size\n  return isNaN(value) ? value : value * fontSize;\n};\nconst matchNumber = value => typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\nconst castFloat = value => {\n  if (typeof value !== 'string') return value;\n  if (matchNumber(value)) return parseFloat(value);\n  return value;\n};\nconst offsetKeyword = value => {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n    case 'right':\n    case 'bottom':\n      return '100%';\n    case 'center':\n      return '50%';\n    default:\n      return null;\n  }\n};\nconst transformObjectPosition = value => offsetKeyword(value) || castFloat(value);\nconst transformTransformOrigin = value => offsetKeyword(value) || castFloat(value);\nconst handlers = {\n  transform: processTransform,\n  fontWeight: processFontWeight,\n  lineHeight: processLineHeight,\n  objectPositionX: transformObjectPosition,\n  objectPositionY: transformObjectPosition,\n  transformOriginX: transformTransformOrigin,\n  transformOriginY: transformTransformOrigin\n};\nconst transformStyle = (key, value, styles, container) => {\n  const result = handlers[key] ? handlers[key](value, styles) : value;\n  return transformColor(transformUnit(container, castFloat(result)));\n};\n\n/**\n * @typedef {Function} Transform\n * @param {Object} style styles object\n * @returns {Object} transformed styles\n */\n\n/**\n * Transform styles values\n *\n * @param {Object} container\n * @returns {Transform} transform function\n */\nconst transform = container => styles => {\n  if (!styles) return styles;\n  const propsArray = Object.keys(styles);\n  const resolvedStyle = {};\n  for (let i = 0; i < propsArray.length; i += 1) {\n    const key = propsArray[i];\n    const value = styles[key];\n    const transformed = transformStyle(key, value, styles, container);\n    resolvedStyle[key] = transformed;\n  }\n  return resolvedStyle;\n};\n\n/**\n * Resolves media queries in styles object\n *\n * @param {Object} container\n * @param {Object} styles object\n */\nconst resolveMediaQueries = (container, styles) => {\n  return Object.keys(styles).reduce((acc, key) => {\n    if (/@media/.test(key)) {\n      return {\n        ...acc,\n        ...matchMedia({\n          [key]: styles[key]\n        }, container)\n      };\n    }\n    return {\n      ...acc,\n      [key]: styles[key]\n    };\n  }, {});\n};\n\n/**\n * Resolves styles\n *\n * @param {Object} container\n * @param {Object} style object\n * @returns {Object} resolved style object\n */\nconst resolveStyles = (container, style) => {\n  const computeMediaQueries = value => resolveMediaQueries(container, value);\n  return compose(transform(container), expand, computeMediaQueries, flatten)(style);\n};\nexport { resolveStyles as default, flatten, processTransform, transformColor };","map":{"version":3,"names":["compose","castArray","matchPercent","parse$1","parseUnit","hlsToHex","colorString","matchMedia","flexDefaults","flexAuto","expandFlex","key","value","defaults","matches","split","flexGrow","flexShrink","flexBasis","BOX_MODEL_UNITS","logError","style","console","error","repeat","length","expandBoxModel","_temp","expandsTo","maxValues","autoSupported","model","nodes","parts","i","node","type","push","result","includes","unit","first","second","third","fourth","processMargin","_ref","marginTop","marginRight","marginBottom","marginLeft","processMarginVertical","_ref2","processMarginHorizontal","_ref3","processMarginSingle","BORDER_SHORTHAND_REGEX","matchBorderShorthand","match","expandBorders","color","width","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","borderTopStyle","borderRightStyle","borderBottomStyle","borderLeftStyle","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","processPadding","paddingTop","paddingRight","paddingBottom","paddingLeft","processPaddingVertical","processPaddingHorizontal","processPaddingSingle","expandObjectPosition","objectPositionX","objectPositionY","Y_AXIS_SHORTHANDS","top","bottom","sortTransformOriginPair","a","b","getTransformOriginPair","values","pair","sort","expandTransformOrigin","transformOriginX","transformOriginY","expandGap","rowGap","columnGap","shorthands","flex","gap","margin","marginHorizontal","marginVertical","padding","paddingHorizontal","paddingVertical","border","borderTop","borderRight","borderBottom","borderLeft","borderColor","borderRadius","borderStyle","borderWidth","objectPosition","transformOrigin","expandStyle","expand","propsArray","Object","keys","resolvedStyle","extended","j","propName","propValue","compact","array","filter","Boolean","mergeStyles","styles","reduce","acc","s","Array","isArray","flatten","forEach","undefined","parseValue","exec","parseFloat","transformUnit","container","scalar","outputDpi","inputDpi","dpi","mmFactor","cmFactor","remBase","height","Math","round","isRgb","test","isHsl","parseRgb","rgb","get","to","hex","parseHsl","hsl","map","toUpperCase","transformColor","parse","transformString","transforms","trim","parsed","transform","name","rawValue","splitChar","indexOf","val","operation","parseAngle","unitsRegexp","angle","number","Number","PI","normalizeTransformOperation","scaleX","scaleY","num","normalize","operations","processTransform","FONT_WEIGHTS","thin","hairline","ultralight","extralight","light","normal","medium","semibold","demibold","bold","ultrabold","extrabold","heavy","black","processFontWeight","lv","toLowerCase","processLineHeight","fontSize","percent","isNaN","matchNumber","castFloat","offsetKeyword","transformObjectPosition","transformTransformOrigin","handlers","fontWeight","lineHeight","transformStyle","transformed","resolveMediaQueries","resolveStyles","computeMediaQueries","default"],"sources":["C:/Users/SHIVA CHAITANYA/Desktop/New Builds/BlogProject/node_modules/@react-pdf/stylesheet/lib/index.js"],"sourcesContent":["import { compose, castArray, matchPercent } from '@react-pdf/fns';\nimport parse$1 from 'postcss-value-parser/lib/parse.js';\nimport parseUnit from 'postcss-value-parser/lib/unit.js';\nimport hlsToHex from 'hsl-to-hex';\nimport colorString from 'color-string';\nimport matchMedia from 'media-engine';\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\n\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\nconst flexDefaults = [1, 1, 0];\n/**\n * @type {(number | 'auto')[]}\n */\nconst flexAuto = [1, 1, 'auto'];\nconst expandFlex = (key, value) => {\n  /**\n   * @type {(number | 'auto')[]}\n   */\n  let defaults = flexDefaults;\n  let matches = [];\n  if (value === 'auto') {\n    defaults = flexAuto;\n  } else {\n    matches = `${value}`.split(' ');\n  }\n  const flexGrow = matches[0] || defaults[0];\n  const flexShrink = matches[1] || defaults[1];\n  const flexBasis = matches[2] || defaults[2];\n  return {\n    flexGrow,\n    flexShrink,\n    flexBasis\n  };\n};\n\n/* eslint-disable no-plusplus */\n// This file is ran directly with Node - needs to have .js extension\n// eslint-disable-next-line import/extensions\nconst BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\nconst logError = (style, value) => {\n  console.error(`\n    @react-pdf/stylesheet parsing error:\n\n    ${style}: ${value},\n    ${' '.repeat(style.length + 2)}^\n    Unsupported ${style} value format\n  `);\n};\n\n/**\n * @param {Object} options\n * @param {Function} [options.expandsTo]\n * @param {number} [options.maxValues]\n * @param {boolean} [options.autoSupported]\n */\nconst expandBoxModel = function (_temp) {\n  let {\n    expandsTo,\n    maxValues = 1,\n    autoSupported = false\n  } = _temp === void 0 ? {} : _temp;\n  return (model, value) => {\n    const nodes = parse$1(`${value}`);\n    const parts = [];\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      // value contains `calc`, `url` or other css function\n      // `,`, `/` or strings that unsupported by margin and padding\n      if (node.type === 'function' || node.type === 'string' || node.type === 'div') {\n        logError(model, value);\n        return {};\n      }\n      if (node.type === 'word') {\n        if (node.value === 'auto' && autoSupported) {\n          parts.push(node.value);\n        } else {\n          const result = parseUnit(node.value);\n\n          // when unit isn't specified this condition is true\n          if (result && BOX_MODEL_UNITS.includes(result.unit)) {\n            parts.push(node.value);\n          } else {\n            logError(model, value);\n            return {};\n          }\n        }\n      }\n    }\n\n    // checks that we have enough parsed values\n    if (parts.length > maxValues) {\n      logError(model, value);\n      return {};\n    }\n    const first = parts[0];\n    if (expandsTo) {\n      const second = parts[1] || parts[0];\n      const third = parts[2] || parts[0];\n      const fourth = parts[3] || parts[1] || parts[0];\n      return expandsTo({\n        first,\n        second,\n        third,\n        fourth\n      });\n    }\n    return {\n      [model]: first\n    };\n  };\n};\n\nconst processMargin = expandBoxModel({\n  expandsTo: _ref => {\n    let {\n      first,\n      second,\n      third,\n      fourth\n    } = _ref;\n    return {\n      marginTop: first,\n      marginRight: second,\n      marginBottom: third,\n      marginLeft: fourth\n    };\n  },\n  maxValues: 4,\n  autoSupported: true\n});\nconst processMarginVertical = expandBoxModel({\n  expandsTo: _ref2 => {\n    let {\n      first,\n      second\n    } = _ref2;\n    return {\n      marginTop: first,\n      marginBottom: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginHorizontal = expandBoxModel({\n  expandsTo: _ref3 => {\n    let {\n      first,\n      second\n    } = _ref3;\n    return {\n      marginRight: first,\n      marginLeft: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginSingle = expandBoxModel({\n  autoSupported: true\n});\n\nconst BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\\s(\\S+)\\s(.+)/;\nconst matchBorderShorthand = value => value.match(BORDER_SHORTHAND_REGEX) || [];\nconst expandBorders = (key, value) => {\n  const match = matchBorderShorthand(`${value}`);\n  if (match) {\n    const color = match[5] || value;\n    const style = match[4] || value;\n    const width = match[1] || value;\n    if (key.match(/(Top|Right|Bottom|Left)$/)) {\n      return {\n        [`${key}Color`]: color,\n        [`${key}Style`]: style,\n        [`${key}Width`]: width\n      };\n    }\n    if (key.match(/Color$/)) {\n      return {\n        borderTopColor: color,\n        borderRightColor: color,\n        borderBottomColor: color,\n        borderLeftColor: color\n      };\n    }\n    if (key.match(/Style$/)) {\n      return {\n        borderTopStyle: style,\n        borderRightStyle: style,\n        borderBottomStyle: style,\n        borderLeftStyle: style\n      };\n    }\n    if (key.match(/Width$/)) {\n      return {\n        borderTopWidth: width,\n        borderRightWidth: width,\n        borderBottomWidth: width,\n        borderLeftWidth: width\n      };\n    }\n    if (key.match(/Radius$/)) {\n      return {\n        borderTopLeftRadius: value,\n        borderTopRightRadius: value,\n        borderBottomRightRadius: value,\n        borderBottomLeftRadius: value\n      };\n    }\n    return {\n      borderTopColor: color,\n      borderTopStyle: style,\n      borderTopWidth: width,\n      borderRightColor: color,\n      borderRightStyle: style,\n      borderRightWidth: width,\n      borderBottomColor: color,\n      borderBottomStyle: style,\n      borderBottomWidth: width,\n      borderLeftColor: color,\n      borderLeftStyle: style,\n      borderLeftWidth: width\n    };\n  }\n  return value;\n};\n\nconst processPadding = expandBoxModel({\n  expandsTo: _ref => {\n    let {\n      first,\n      second,\n      third,\n      fourth\n    } = _ref;\n    return {\n      paddingTop: first,\n      paddingRight: second,\n      paddingBottom: third,\n      paddingLeft: fourth\n    };\n  },\n  maxValues: 4\n});\nconst processPaddingVertical = expandBoxModel({\n  expandsTo: _ref2 => {\n    let {\n      first,\n      second\n    } = _ref2;\n    return {\n      paddingTop: first,\n      paddingBottom: second\n    };\n  },\n  maxValues: 2\n});\nconst processPaddingHorizontal = expandBoxModel({\n  expandsTo: _ref3 => {\n    let {\n      first,\n      second\n    } = _ref3;\n    return {\n      paddingRight: first,\n      paddingLeft: second\n    };\n  },\n  maxValues: 2\n});\nconst processPaddingSingle = expandBoxModel();\n\nconst expandObjectPosition = (key, value) => {\n  const match = `${value}`.split(' ');\n  return {\n    objectPositionX: (match === null || match === void 0 ? void 0 : match[0]) || value,\n    objectPositionY: (match === null || match === void 0 ? void 0 : match[1]) || value\n  };\n};\n\nconst Y_AXIS_SHORTHANDS = {\n  top: true,\n  bottom: true\n};\nconst sortTransformOriginPair = (a, b) => {\n  if (Y_AXIS_SHORTHANDS[a]) return 1;\n  if (Y_AXIS_SHORTHANDS[b]) return -1;\n  return 0;\n};\nconst getTransformOriginPair = values => {\n  if (!values || values.length === 0) return ['center', 'center'];\n  const pair = values.length === 1 ? [values[0], 'center'] : values;\n  return pair.sort(sortTransformOriginPair);\n};\n\n// Transforms shorthand transformOrigin values\nconst expandTransformOrigin = (key, value) => {\n  const match = `${value}`.split(' ');\n  const pair = getTransformOriginPair(match);\n  return {\n    transformOriginX: pair[0],\n    transformOriginY: pair[1]\n  };\n};\n\nconst expandGap = (key, value) => {\n  const match = `${value}`.split(' ');\n  return {\n    rowGap: (match === null || match === void 0 ? void 0 : match[0]) || value,\n    columnGap: (match === null || match === void 0 ? void 0 : match[1]) || value\n  };\n};\n\nconst shorthands = {\n  flex: expandFlex,\n  gap: expandGap,\n  margin: processMargin,\n  marginHorizontal: processMarginHorizontal,\n  marginVertical: processMarginVertical,\n  marginTop: processMarginSingle,\n  marginRight: processMarginSingle,\n  marginBottom: processMarginSingle,\n  marginLeft: processMarginSingle,\n  padding: processPadding,\n  paddingHorizontal: processPaddingHorizontal,\n  paddingVertical: processPaddingVertical,\n  paddingTop: processPaddingSingle,\n  paddingRight: processPaddingSingle,\n  paddingBottom: processPaddingSingle,\n  paddingLeft: processPaddingSingle,\n  border: expandBorders,\n  borderTop: expandBorders,\n  borderRight: expandBorders,\n  borderBottom: expandBorders,\n  borderLeft: expandBorders,\n  borderColor: expandBorders,\n  borderRadius: expandBorders,\n  borderStyle: expandBorders,\n  borderWidth: expandBorders,\n  objectPosition: expandObjectPosition,\n  transformOrigin: expandTransformOrigin\n};\n\n/**\n * Transforms style key-value\n *\n * @param {string} key style key\n * @param {string} value style value\n * @returns {string | Number} transformed style values\n */\nconst expandStyle = (key, value) => {\n  return shorthands[key] ? shorthands[key](key, value) : {\n    [key]: value\n  };\n};\n\n/**\n * Expand the shorthand properties.\n *\n * @param {Object} style object\n * @returns {Object} expanded style object\n */\nconst expand = style => {\n  if (!style) return style;\n  const propsArray = Object.keys(style);\n  const resolvedStyle = {};\n  for (let i = 0; i < propsArray.length; i += 1) {\n    const key = propsArray[i];\n    const value = style[key];\n    const extended = expandStyle(key, value);\n    const keys = Object.keys(extended);\n    for (let j = 0; j < keys.length; j += 1) {\n      const propName = keys[j];\n      const propValue = extended[propName];\n      resolvedStyle[propName] = propValue;\n    }\n  }\n  return resolvedStyle;\n};\n\n/**\n * Remove nil values from array\n *\n * @template T\n * @param {(T | null | undefined)[]} array\n * @returns {T[]} array without nils\n */\nconst compact = array => array.filter(Boolean);\n\n/**\n * Merges style objects array\n *\n * @param {Object[]} styles style objects array\n * @returns {Object} merged style object\n */\nconst mergeStyles = styles => styles.reduce((acc, style) => {\n  const s = Array.isArray(style) ? flatten(style) : style;\n  Object.keys(s).forEach(key => {\n    if (s[key] !== null && s[key] !== undefined) {\n      acc[key] = s[key];\n    }\n  });\n  return acc;\n}, {});\n\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param {Object[]} styles style objects array\n * @returns {Object} flattened style object\n */\nconst flatten = compose(mergeStyles, compact, castArray);\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {string} value scalar value\n * @returns {Object} parsed value\n */\nconst parseValue = value => {\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value,\n    unit: undefined\n  };\n};\n\n/**\n * Transform given scalar value\n *\n * @param {Object} container\n * @param {string} value styles value\n * @returns {Object} transformed value\n */\nconst transformUnit = (container, value) => {\n  const scalar = parseValue(value);\n  const outputDpi = 72;\n  const inputDpi = container.dpi || 72;\n  const mmFactor = 1 / 25.4 * outputDpi;\n  const cmFactor = 1 / 2.54 * outputDpi;\n  switch (scalar.unit) {\n    case 'rem':\n      return scalar.value * (container.remBase || 18);\n    case 'in':\n      return scalar.value * outputDpi;\n    case 'mm':\n      return scalar.value * mmFactor;\n    case 'cm':\n      return scalar.value * cmFactor;\n    case 'vh':\n      return scalar.value * (container.height / 100);\n    case 'vw':\n      return scalar.value * (container.width / 100);\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n    default:\n      return scalar.value;\n  }\n};\n\nconst isRgb = value => /rgba?/g.test(value);\nconst isHsl = value => /hsla?/g.test(value);\n\n/**\n * Transform rgb color to hexa\n *\n * @param {string} value styles value\n * @returns {Object} transformed value\n */\nconst parseRgb = value => {\n  const rgb = colorString.get.rgb(value);\n  return colorString.to.hex(rgb);\n};\n\n/**\n * Transform Hsl color to hexa\n *\n * @param {string} value styles value\n * @returns {Object} transformed value\n */\nconst parseHsl = value => {\n  const hsl = colorString.get.hsl(value).map(Math.round);\n  const hex = hlsToHex(...hsl);\n  return hex.toUpperCase();\n};\n\n/**\n * Transform given color to hexa\n *\n * @param {string} value styles value\n * @returns {Object} transformed value\n */\nconst transformColor = value => {\n  if (isRgb(value)) return parseRgb(value);\n  if (isHsl(value)) return parseHsl(value);\n  return value;\n};\n\nconst parse = transformString => {\n  const transforms = transformString.trim().split(/\\)[ ,]|\\)/);\n\n  // Handle \"initial\", \"inherit\", \"unset\".\n  if (transforms.length === 1) {\n    return [[transforms[0], true]];\n  }\n  const parsed = [];\n  for (let i = 0; i < transforms.length; i += 1) {\n    const transform = transforms[i];\n    if (transform) {\n      const [name, rawValue] = transform.split('(');\n      const splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\n      const value = rawValue.split(splitChar).map(val => val.trim());\n      parsed.push({\n        operation: name.trim(),\n        value\n      });\n    }\n  }\n  return parsed;\n};\nconst parseAngle = value => {\n  const unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\n  const [, angle, unit] = unitsRegexp.exec(value);\n  const number = Number.parseFloat(angle);\n  return unit === 'rad' ? number * 180 / Math.PI : number;\n};\nconst normalizeTransformOperation = _ref => {\n  let {\n    operation,\n    value\n  } = _ref;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY = scaleX] = value.map(num => Number.parseFloat(num));\n        return {\n          operation: 'scale',\n          value: [scaleX, scaleY]\n        };\n      }\n    case 'scaleX':\n      {\n        return {\n          operation: 'scale',\n          value: [Number.parseFloat(value), 1]\n        };\n      }\n    case 'scaleY':\n      {\n        return {\n          operation: 'scale',\n          value: [1, Number.parseFloat(value)]\n        };\n      }\n    case 'rotate':\n      {\n        return {\n          operation: 'rotate',\n          value: [parseAngle(value)]\n        };\n      }\n    case 'translate':\n      {\n        return {\n          operation: 'translate',\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n    case 'translateX':\n      {\n        return {\n          operation: 'translate',\n          value: [Number.parseFloat(value), 0]\n        };\n      }\n    case 'translateY':\n      {\n        return {\n          operation: 'translate',\n          value: [0, Number.parseFloat(value)]\n        };\n      }\n    case 'skew':\n      {\n        return {\n          operation: 'skew',\n          value: value.map(parseAngle)\n        };\n      }\n    case 'skewX':\n      {\n        return {\n          operation: 'skew',\n          value: [parseAngle(value), 0]\n        };\n      }\n    case 'skewY':\n      {\n        return {\n          operation: 'skew',\n          value: [0, parseAngle(value)]\n        };\n      }\n    default:\n      {\n        return {\n          operation,\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n  }\n};\nconst normalize = operations => {\n  return operations.map(operation => normalizeTransformOperation(operation));\n};\nconst processTransform = value => {\n  if (typeof value !== 'string') return value;\n  return normalize(parse(value));\n};\n\nconst FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900\n};\nconst processFontWeight = value => {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  const lv = value.toLowerCase();\n  if (FONT_WEIGHTS[lv]) return FONT_WEIGHTS[lv];\n  return value;\n};\n\n/* eslint-disable no-restricted-globals */\n\nconst processLineHeight = (value, styles) => {\n  if (value === '') return value;\n  const {\n    fontSize = 18\n  } = styles;\n\n  // Percent values: use this number multiplied by the element's font size\n  const {\n    percent\n  } = matchPercent(value) || {};\n  if (percent) return percent * fontSize;\n\n  // Unitless values: use this number multiplied by the element's font size\n  return isNaN(value) ? value : value * fontSize;\n};\n\nconst matchNumber = value => typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\nconst castFloat = value => {\n  if (typeof value !== 'string') return value;\n  if (matchNumber(value)) return parseFloat(value);\n  return value;\n};\n\nconst offsetKeyword = value => {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n    case 'right':\n    case 'bottom':\n      return '100%';\n    case 'center':\n      return '50%';\n    default:\n      return null;\n  }\n};\n\nconst transformObjectPosition = value => offsetKeyword(value) || castFloat(value);\n\nconst transformTransformOrigin = value => offsetKeyword(value) || castFloat(value);\n\nconst handlers = {\n  transform: processTransform,\n  fontWeight: processFontWeight,\n  lineHeight: processLineHeight,\n  objectPositionX: transformObjectPosition,\n  objectPositionY: transformObjectPosition,\n  transformOriginX: transformTransformOrigin,\n  transformOriginY: transformTransformOrigin\n};\nconst transformStyle = (key, value, styles, container) => {\n  const result = handlers[key] ? handlers[key](value, styles) : value;\n  return transformColor(transformUnit(container, castFloat(result)));\n};\n\n/**\n * @typedef {Function} Transform\n * @param {Object} style styles object\n * @returns {Object} transformed styles\n */\n\n/**\n * Transform styles values\n *\n * @param {Object} container\n * @returns {Transform} transform function\n */\nconst transform = container => styles => {\n  if (!styles) return styles;\n  const propsArray = Object.keys(styles);\n  const resolvedStyle = {};\n  for (let i = 0; i < propsArray.length; i += 1) {\n    const key = propsArray[i];\n    const value = styles[key];\n    const transformed = transformStyle(key, value, styles, container);\n    resolvedStyle[key] = transformed;\n  }\n  return resolvedStyle;\n};\n\n/**\n * Resolves media queries in styles object\n *\n * @param {Object} container\n * @param {Object} styles object\n */\nconst resolveMediaQueries = (container, styles) => {\n  return Object.keys(styles).reduce((acc, key) => {\n    if (/@media/.test(key)) {\n      return {\n        ...acc,\n        ...matchMedia({\n          [key]: styles[key]\n        }, container)\n      };\n    }\n    return {\n      ...acc,\n      [key]: styles[key]\n    };\n  }, {});\n};\n\n/**\n * Resolves styles\n *\n * @param {Object} container\n * @param {Object} style object\n * @returns {Object} resolved style object\n */\nconst resolveStyles = (container, style) => {\n  const computeMediaQueries = value => resolveMediaQueries(container, value);\n  return compose(transform(container), expand, computeMediaQueries, flatten)(style);\n};\n\nexport { resolveStyles as default, flatten, processTransform, transformColor };\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,SAAS,EAAEC,YAAY,QAAQ,gBAAgB;AACjE,OAAOC,OAAO,MAAM,mCAAmC;AACvD,OAAOC,SAAS,MAAM,kCAAkC;AACxD,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,WAAW,MAAM,cAAc;AACtC,OAAOC,UAAU,MAAM,cAAc;;AAErC;;AAEA;AACA,MAAMC,YAAY,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAC9B;AACA;AACA;AACA,MAAMC,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC;AAC/B,MAAMC,UAAU,GAAGA,CAACC,GAAG,EAAEC,KAAK,KAAK;EACjC;AACF;AACA;EACE,IAAIC,QAAQ,GAAGL,YAAY;EAC3B,IAAIM,OAAO,GAAG,EAAE;EAChB,IAAIF,KAAK,KAAK,MAAM,EAAE;IACpBC,QAAQ,GAAGJ,QAAQ;EACrB,CAAC,MAAM;IACLK,OAAO,GAAG,GAAGF,KAAK,EAAE,CAACG,KAAK,CAAC,GAAG,CAAC;EACjC;EACA,MAAMC,QAAQ,GAAGF,OAAO,CAAC,CAAC,CAAC,IAAID,QAAQ,CAAC,CAAC,CAAC;EAC1C,MAAMI,UAAU,GAAGH,OAAO,CAAC,CAAC,CAAC,IAAID,QAAQ,CAAC,CAAC,CAAC;EAC5C,MAAMK,SAAS,GAAGJ,OAAO,CAAC,CAAC,CAAC,IAAID,QAAQ,CAAC,CAAC,CAAC;EAC3C,OAAO;IACLG,QAAQ;IACRC,UAAU;IACVC;EACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA,MAAMC,eAAe,GAAG,wBAAwB;AAChD,MAAMC,QAAQ,GAAGA,CAACC,KAAK,EAAET,KAAK,KAAK;EACjCU,OAAO,CAACC,KAAK,CAAC;AAChB;AACA;AACA,MAAMF,KAAK,KAAKT,KAAK;AACrB,MAAM,GAAG,CAACY,MAAM,CAACH,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC;AAClC,kBAAkBJ,KAAK;AACvB,GAAG,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,cAAc,GAAG,SAAAA,CAAUC,KAAK,EAAE;EACtC,IAAI;IACFC,SAAS;IACTC,SAAS,GAAG,CAAC;IACbC,aAAa,GAAG;EAClB,CAAC,GAAGH,KAAK,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,KAAK;EACjC,OAAO,CAACI,KAAK,EAAEnB,KAAK,KAAK;IACvB,MAAMoB,KAAK,GAAG7B,OAAO,CAAC,GAAGS,KAAK,EAAE,CAAC;IACjC,MAAMqB,KAAK,GAAG,EAAE;IAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,CAACP,MAAM,EAAES,CAAC,EAAE,EAAE;MACrC,MAAMC,IAAI,GAAGH,KAAK,CAACE,CAAC,CAAC;;MAErB;MACA;MACA,IAAIC,IAAI,CAACC,IAAI,KAAK,UAAU,IAAID,IAAI,CAACC,IAAI,KAAK,QAAQ,IAAID,IAAI,CAACC,IAAI,KAAK,KAAK,EAAE;QAC7EhB,QAAQ,CAACW,KAAK,EAAEnB,KAAK,CAAC;QACtB,OAAO,CAAC,CAAC;MACX;MACA,IAAIuB,IAAI,CAACC,IAAI,KAAK,MAAM,EAAE;QACxB,IAAID,IAAI,CAACvB,KAAK,KAAK,MAAM,IAAIkB,aAAa,EAAE;UAC1CG,KAAK,CAACI,IAAI,CAACF,IAAI,CAACvB,KAAK,CAAC;QACxB,CAAC,MAAM;UACL,MAAM0B,MAAM,GAAGlC,SAAS,CAAC+B,IAAI,CAACvB,KAAK,CAAC;;UAEpC;UACA,IAAI0B,MAAM,IAAInB,eAAe,CAACoB,QAAQ,CAACD,MAAM,CAACE,IAAI,CAAC,EAAE;YACnDP,KAAK,CAACI,IAAI,CAACF,IAAI,CAACvB,KAAK,CAAC;UACxB,CAAC,MAAM;YACLQ,QAAQ,CAACW,KAAK,EAAEnB,KAAK,CAAC;YACtB,OAAO,CAAC,CAAC;UACX;QACF;MACF;IACF;;IAEA;IACA,IAAIqB,KAAK,CAACR,MAAM,GAAGI,SAAS,EAAE;MAC5BT,QAAQ,CAACW,KAAK,EAAEnB,KAAK,CAAC;MACtB,OAAO,CAAC,CAAC;IACX;IACA,MAAM6B,KAAK,GAAGR,KAAK,CAAC,CAAC,CAAC;IACtB,IAAIL,SAAS,EAAE;MACb,MAAMc,MAAM,GAAGT,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC;MACnC,MAAMU,KAAK,GAAGV,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC;MAClC,MAAMW,MAAM,GAAGX,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC;MAC/C,OAAOL,SAAS,CAAC;QACfa,KAAK;QACLC,MAAM;QACNC,KAAK;QACLC;MACF,CAAC,CAAC;IACJ;IACA,OAAO;MACL,CAACb,KAAK,GAAGU;IACX,CAAC;EACH,CAAC;AACH,CAAC;AAED,MAAMI,aAAa,GAAGnB,cAAc,CAAC;EACnCE,SAAS,EAAEkB,IAAI,IAAI;IACjB,IAAI;MACFL,KAAK;MACLC,MAAM;MACNC,KAAK;MACLC;IACF,CAAC,GAAGE,IAAI;IACR,OAAO;MACLC,SAAS,EAAEN,KAAK;MAChBO,WAAW,EAAEN,MAAM;MACnBO,YAAY,EAAEN,KAAK;MACnBO,UAAU,EAAEN;IACd,CAAC;EACH,CAAC;EACDf,SAAS,EAAE,CAAC;EACZC,aAAa,EAAE;AACjB,CAAC,CAAC;AACF,MAAMqB,qBAAqB,GAAGzB,cAAc,CAAC;EAC3CE,SAAS,EAAEwB,KAAK,IAAI;IAClB,IAAI;MACFX,KAAK;MACLC;IACF,CAAC,GAAGU,KAAK;IACT,OAAO;MACLL,SAAS,EAAEN,KAAK;MAChBQ,YAAY,EAAEP;IAChB,CAAC;EACH,CAAC;EACDb,SAAS,EAAE,CAAC;EACZC,aAAa,EAAE;AACjB,CAAC,CAAC;AACF,MAAMuB,uBAAuB,GAAG3B,cAAc,CAAC;EAC7CE,SAAS,EAAE0B,KAAK,IAAI;IAClB,IAAI;MACFb,KAAK;MACLC;IACF,CAAC,GAAGY,KAAK;IACT,OAAO;MACLN,WAAW,EAAEP,KAAK;MAClBS,UAAU,EAAER;IACd,CAAC;EACH,CAAC;EACDb,SAAS,EAAE,CAAC;EACZC,aAAa,EAAE;AACjB,CAAC,CAAC;AACF,MAAMyB,mBAAmB,GAAG7B,cAAc,CAAC;EACzCI,aAAa,EAAE;AACjB,CAAC,CAAC;AAEF,MAAM0B,sBAAsB,GAAG,yDAAyD;AACxF,MAAMC,oBAAoB,GAAG7C,KAAK,IAAIA,KAAK,CAAC8C,KAAK,CAACF,sBAAsB,CAAC,IAAI,EAAE;AAC/E,MAAMG,aAAa,GAAGA,CAAChD,GAAG,EAAEC,KAAK,KAAK;EACpC,MAAM8C,KAAK,GAAGD,oBAAoB,CAAC,GAAG7C,KAAK,EAAE,CAAC;EAC9C,IAAI8C,KAAK,EAAE;IACT,MAAME,KAAK,GAAGF,KAAK,CAAC,CAAC,CAAC,IAAI9C,KAAK;IAC/B,MAAMS,KAAK,GAAGqC,KAAK,CAAC,CAAC,CAAC,IAAI9C,KAAK;IAC/B,MAAMiD,KAAK,GAAGH,KAAK,CAAC,CAAC,CAAC,IAAI9C,KAAK;IAC/B,IAAID,GAAG,CAAC+C,KAAK,CAAC,0BAA0B,CAAC,EAAE;MACzC,OAAO;QACL,CAAC,GAAG/C,GAAG,OAAO,GAAGiD,KAAK;QACtB,CAAC,GAAGjD,GAAG,OAAO,GAAGU,KAAK;QACtB,CAAC,GAAGV,GAAG,OAAO,GAAGkD;MACnB,CAAC;IACH;IACA,IAAIlD,GAAG,CAAC+C,KAAK,CAAC,QAAQ,CAAC,EAAE;MACvB,OAAO;QACLI,cAAc,EAAEF,KAAK;QACrBG,gBAAgB,EAAEH,KAAK;QACvBI,iBAAiB,EAAEJ,KAAK;QACxBK,eAAe,EAAEL;MACnB,CAAC;IACH;IACA,IAAIjD,GAAG,CAAC+C,KAAK,CAAC,QAAQ,CAAC,EAAE;MACvB,OAAO;QACLQ,cAAc,EAAE7C,KAAK;QACrB8C,gBAAgB,EAAE9C,KAAK;QACvB+C,iBAAiB,EAAE/C,KAAK;QACxBgD,eAAe,EAAEhD;MACnB,CAAC;IACH;IACA,IAAIV,GAAG,CAAC+C,KAAK,CAAC,QAAQ,CAAC,EAAE;MACvB,OAAO;QACLY,cAAc,EAAET,KAAK;QACrBU,gBAAgB,EAAEV,KAAK;QACvBW,iBAAiB,EAAEX,KAAK;QACxBY,eAAe,EAAEZ;MACnB,CAAC;IACH;IACA,IAAIlD,GAAG,CAAC+C,KAAK,CAAC,SAAS,CAAC,EAAE;MACxB,OAAO;QACLgB,mBAAmB,EAAE9D,KAAK;QAC1B+D,oBAAoB,EAAE/D,KAAK;QAC3BgE,uBAAuB,EAAEhE,KAAK;QAC9BiE,sBAAsB,EAAEjE;MAC1B,CAAC;IACH;IACA,OAAO;MACLkD,cAAc,EAAEF,KAAK;MACrBM,cAAc,EAAE7C,KAAK;MACrBiD,cAAc,EAAET,KAAK;MACrBE,gBAAgB,EAAEH,KAAK;MACvBO,gBAAgB,EAAE9C,KAAK;MACvBkD,gBAAgB,EAAEV,KAAK;MACvBG,iBAAiB,EAAEJ,KAAK;MACxBQ,iBAAiB,EAAE/C,KAAK;MACxBmD,iBAAiB,EAAEX,KAAK;MACxBI,eAAe,EAAEL,KAAK;MACtBS,eAAe,EAAEhD,KAAK;MACtBoD,eAAe,EAAEZ;IACnB,CAAC;EACH;EACA,OAAOjD,KAAK;AACd,CAAC;AAED,MAAMkE,cAAc,GAAGpD,cAAc,CAAC;EACpCE,SAAS,EAAEkB,IAAI,IAAI;IACjB,IAAI;MACFL,KAAK;MACLC,MAAM;MACNC,KAAK;MACLC;IACF,CAAC,GAAGE,IAAI;IACR,OAAO;MACLiC,UAAU,EAAEtC,KAAK;MACjBuC,YAAY,EAAEtC,MAAM;MACpBuC,aAAa,EAAEtC,KAAK;MACpBuC,WAAW,EAAEtC;IACf,CAAC;EACH,CAAC;EACDf,SAAS,EAAE;AACb,CAAC,CAAC;AACF,MAAMsD,sBAAsB,GAAGzD,cAAc,CAAC;EAC5CE,SAAS,EAAEwB,KAAK,IAAI;IAClB,IAAI;MACFX,KAAK;MACLC;IACF,CAAC,GAAGU,KAAK;IACT,OAAO;MACL2B,UAAU,EAAEtC,KAAK;MACjBwC,aAAa,EAAEvC;IACjB,CAAC;EACH,CAAC;EACDb,SAAS,EAAE;AACb,CAAC,CAAC;AACF,MAAMuD,wBAAwB,GAAG1D,cAAc,CAAC;EAC9CE,SAAS,EAAE0B,KAAK,IAAI;IAClB,IAAI;MACFb,KAAK;MACLC;IACF,CAAC,GAAGY,KAAK;IACT,OAAO;MACL0B,YAAY,EAAEvC,KAAK;MACnByC,WAAW,EAAExC;IACf,CAAC;EACH,CAAC;EACDb,SAAS,EAAE;AACb,CAAC,CAAC;AACF,MAAMwD,oBAAoB,GAAG3D,cAAc,CAAC,CAAC;AAE7C,MAAM4D,oBAAoB,GAAGA,CAAC3E,GAAG,EAAEC,KAAK,KAAK;EAC3C,MAAM8C,KAAK,GAAG,GAAG9C,KAAK,EAAE,CAACG,KAAK,CAAC,GAAG,CAAC;EACnC,OAAO;IACLwE,eAAe,EAAE,CAAC7B,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,KAAK9C,KAAK;IAClF4E,eAAe,EAAE,CAAC9B,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,KAAK9C;EAC/E,CAAC;AACH,CAAC;AAED,MAAM6E,iBAAiB,GAAG;EACxBC,GAAG,EAAE,IAAI;EACTC,MAAM,EAAE;AACV,CAAC;AACD,MAAMC,uBAAuB,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;EACxC,IAAIL,iBAAiB,CAACI,CAAC,CAAC,EAAE,OAAO,CAAC;EAClC,IAAIJ,iBAAiB,CAACK,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;EACnC,OAAO,CAAC;AACV,CAAC;AACD,MAAMC,sBAAsB,GAAGC,MAAM,IAAI;EACvC,IAAI,CAACA,MAAM,IAAIA,MAAM,CAACvE,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC,QAAQ,EAAE,QAAQ,CAAC;EAC/D,MAAMwE,IAAI,GAAGD,MAAM,CAACvE,MAAM,KAAK,CAAC,GAAG,CAACuE,MAAM,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,GAAGA,MAAM;EACjE,OAAOC,IAAI,CAACC,IAAI,CAACN,uBAAuB,CAAC;AAC3C,CAAC;;AAED;AACA,MAAMO,qBAAqB,GAAGA,CAACxF,GAAG,EAAEC,KAAK,KAAK;EAC5C,MAAM8C,KAAK,GAAG,GAAG9C,KAAK,EAAE,CAACG,KAAK,CAAC,GAAG,CAAC;EACnC,MAAMkF,IAAI,GAAGF,sBAAsB,CAACrC,KAAK,CAAC;EAC1C,OAAO;IACL0C,gBAAgB,EAAEH,IAAI,CAAC,CAAC,CAAC;IACzBI,gBAAgB,EAAEJ,IAAI,CAAC,CAAC;EAC1B,CAAC;AACH,CAAC;AAED,MAAMK,SAAS,GAAGA,CAAC3F,GAAG,EAAEC,KAAK,KAAK;EAChC,MAAM8C,KAAK,GAAG,GAAG9C,KAAK,EAAE,CAACG,KAAK,CAAC,GAAG,CAAC;EACnC,OAAO;IACLwF,MAAM,EAAE,CAAC7C,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,KAAK9C,KAAK;IACzE4F,SAAS,EAAE,CAAC9C,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,KAAK9C;EACzE,CAAC;AACH,CAAC;AAED,MAAM6F,UAAU,GAAG;EACjBC,IAAI,EAAEhG,UAAU;EAChBiG,GAAG,EAAEL,SAAS;EACdM,MAAM,EAAE/D,aAAa;EACrBgE,gBAAgB,EAAExD,uBAAuB;EACzCyD,cAAc,EAAE3D,qBAAqB;EACrCJ,SAAS,EAAEQ,mBAAmB;EAC9BP,WAAW,EAAEO,mBAAmB;EAChCN,YAAY,EAAEM,mBAAmB;EACjCL,UAAU,EAAEK,mBAAmB;EAC/BwD,OAAO,EAAEjC,cAAc;EACvBkC,iBAAiB,EAAE5B,wBAAwB;EAC3C6B,eAAe,EAAE9B,sBAAsB;EACvCJ,UAAU,EAAEM,oBAAoB;EAChCL,YAAY,EAAEK,oBAAoB;EAClCJ,aAAa,EAAEI,oBAAoB;EACnCH,WAAW,EAAEG,oBAAoB;EACjC6B,MAAM,EAAEvD,aAAa;EACrBwD,SAAS,EAAExD,aAAa;EACxByD,WAAW,EAAEzD,aAAa;EAC1B0D,YAAY,EAAE1D,aAAa;EAC3B2D,UAAU,EAAE3D,aAAa;EACzB4D,WAAW,EAAE5D,aAAa;EAC1B6D,YAAY,EAAE7D,aAAa;EAC3B8D,WAAW,EAAE9D,aAAa;EAC1B+D,WAAW,EAAE/D,aAAa;EAC1BgE,cAAc,EAAErC,oBAAoB;EACpCsC,eAAe,EAAEzB;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM0B,WAAW,GAAGA,CAAClH,GAAG,EAAEC,KAAK,KAAK;EAClC,OAAO6F,UAAU,CAAC9F,GAAG,CAAC,GAAG8F,UAAU,CAAC9F,GAAG,CAAC,CAACA,GAAG,EAAEC,KAAK,CAAC,GAAG;IACrD,CAACD,GAAG,GAAGC;EACT,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMkH,MAAM,GAAGzG,KAAK,IAAI;EACtB,IAAI,CAACA,KAAK,EAAE,OAAOA,KAAK;EACxB,MAAM0G,UAAU,GAAGC,MAAM,CAACC,IAAI,CAAC5G,KAAK,CAAC;EACrC,MAAM6G,aAAa,GAAG,CAAC,CAAC;EACxB,KAAK,IAAIhG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6F,UAAU,CAACtG,MAAM,EAAES,CAAC,IAAI,CAAC,EAAE;IAC7C,MAAMvB,GAAG,GAAGoH,UAAU,CAAC7F,CAAC,CAAC;IACzB,MAAMtB,KAAK,GAAGS,KAAK,CAACV,GAAG,CAAC;IACxB,MAAMwH,QAAQ,GAAGN,WAAW,CAAClH,GAAG,EAAEC,KAAK,CAAC;IACxC,MAAMqH,IAAI,GAAGD,MAAM,CAACC,IAAI,CAACE,QAAQ,CAAC;IAClC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACxG,MAAM,EAAE2G,CAAC,IAAI,CAAC,EAAE;MACvC,MAAMC,QAAQ,GAAGJ,IAAI,CAACG,CAAC,CAAC;MACxB,MAAME,SAAS,GAAGH,QAAQ,CAACE,QAAQ,CAAC;MACpCH,aAAa,CAACG,QAAQ,CAAC,GAAGC,SAAS;IACrC;EACF;EACA,OAAOJ,aAAa;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,OAAO,GAAGC,KAAK,IAAIA,KAAK,CAACC,MAAM,CAACC,OAAO,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAGC,MAAM,IAAIA,MAAM,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEzH,KAAK,KAAK;EAC1D,MAAM0H,CAAC,GAAGC,KAAK,CAACC,OAAO,CAAC5H,KAAK,CAAC,GAAG6H,OAAO,CAAC7H,KAAK,CAAC,GAAGA,KAAK;EACvD2G,MAAM,CAACC,IAAI,CAACc,CAAC,CAAC,CAACI,OAAO,CAACxI,GAAG,IAAI;IAC5B,IAAIoI,CAAC,CAACpI,GAAG,CAAC,KAAK,IAAI,IAAIoI,CAAC,CAACpI,GAAG,CAAC,KAAKyI,SAAS,EAAE;MAC3CN,GAAG,CAACnI,GAAG,CAAC,GAAGoI,CAAC,CAACpI,GAAG,CAAC;IACnB;EACF,CAAC,CAAC;EACF,OAAOmI,GAAG;AACZ,CAAC,EAAE,CAAC,CAAC,CAAC;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,OAAO,GAAGlJ,OAAO,CAAC2I,WAAW,EAAEJ,OAAO,EAAEtI,SAAS,CAAC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMoJ,UAAU,GAAGzI,KAAK,IAAI;EAC1B,MAAM8C,KAAK,GAAG,6CAA6C,CAAC4F,IAAI,CAAC1I,KAAK,CAAC;EACvE,OAAO8C,KAAK,GAAG;IACb9C,KAAK,EAAE2I,UAAU,CAAC7F,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3BlB,IAAI,EAAEkB,KAAK,CAAC,CAAC,CAAC,IAAI;EACpB,CAAC,GAAG;IACF9C,KAAK;IACL4B,IAAI,EAAE4G;EACR,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,aAAa,GAAGA,CAACC,SAAS,EAAE7I,KAAK,KAAK;EAC1C,MAAM8I,MAAM,GAAGL,UAAU,CAACzI,KAAK,CAAC;EAChC,MAAM+I,SAAS,GAAG,EAAE;EACpB,MAAMC,QAAQ,GAAGH,SAAS,CAACI,GAAG,IAAI,EAAE;EACpC,MAAMC,QAAQ,GAAG,CAAC,GAAG,IAAI,GAAGH,SAAS;EACrC,MAAMI,QAAQ,GAAG,CAAC,GAAG,IAAI,GAAGJ,SAAS;EACrC,QAAQD,MAAM,CAAClH,IAAI;IACjB,KAAK,KAAK;MACR,OAAOkH,MAAM,CAAC9I,KAAK,IAAI6I,SAAS,CAACO,OAAO,IAAI,EAAE,CAAC;IACjD,KAAK,IAAI;MACP,OAAON,MAAM,CAAC9I,KAAK,GAAG+I,SAAS;IACjC,KAAK,IAAI;MACP,OAAOD,MAAM,CAAC9I,KAAK,GAAGkJ,QAAQ;IAChC,KAAK,IAAI;MACP,OAAOJ,MAAM,CAAC9I,KAAK,GAAGmJ,QAAQ;IAChC,KAAK,IAAI;MACP,OAAOL,MAAM,CAAC9I,KAAK,IAAI6I,SAAS,CAACQ,MAAM,GAAG,GAAG,CAAC;IAChD,KAAK,IAAI;MACP,OAAOP,MAAM,CAAC9I,KAAK,IAAI6I,SAAS,CAAC5F,KAAK,GAAG,GAAG,CAAC;IAC/C,KAAK,IAAI;MACP,OAAOqG,IAAI,CAACC,KAAK,CAACT,MAAM,CAAC9I,KAAK,IAAI+I,SAAS,GAAGC,QAAQ,CAAC,CAAC;IAC1D;MACE,OAAOF,MAAM,CAAC9I,KAAK;EACvB;AACF,CAAC;AAED,MAAMwJ,KAAK,GAAGxJ,KAAK,IAAI,QAAQ,CAACyJ,IAAI,CAACzJ,KAAK,CAAC;AAC3C,MAAM0J,KAAK,GAAG1J,KAAK,IAAI,QAAQ,CAACyJ,IAAI,CAACzJ,KAAK,CAAC;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM2J,QAAQ,GAAG3J,KAAK,IAAI;EACxB,MAAM4J,GAAG,GAAGlK,WAAW,CAACmK,GAAG,CAACD,GAAG,CAAC5J,KAAK,CAAC;EACtC,OAAON,WAAW,CAACoK,EAAE,CAACC,GAAG,CAACH,GAAG,CAAC;AAChC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,QAAQ,GAAGhK,KAAK,IAAI;EACxB,MAAMiK,GAAG,GAAGvK,WAAW,CAACmK,GAAG,CAACI,GAAG,CAACjK,KAAK,CAAC,CAACkK,GAAG,CAACZ,IAAI,CAACC,KAAK,CAAC;EACtD,MAAMQ,GAAG,GAAGtK,QAAQ,CAAC,GAAGwK,GAAG,CAAC;EAC5B,OAAOF,GAAG,CAACI,WAAW,CAAC,CAAC;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,GAAGpK,KAAK,IAAI;EAC9B,IAAIwJ,KAAK,CAACxJ,KAAK,CAAC,EAAE,OAAO2J,QAAQ,CAAC3J,KAAK,CAAC;EACxC,IAAI0J,KAAK,CAAC1J,KAAK,CAAC,EAAE,OAAOgK,QAAQ,CAAChK,KAAK,CAAC;EACxC,OAAOA,KAAK;AACd,CAAC;AAED,MAAMqK,KAAK,GAAGC,eAAe,IAAI;EAC/B,MAAMC,UAAU,GAAGD,eAAe,CAACE,IAAI,CAAC,CAAC,CAACrK,KAAK,CAAC,WAAW,CAAC;;EAE5D;EACA,IAAIoK,UAAU,CAAC1J,MAAM,KAAK,CAAC,EAAE;IAC3B,OAAO,CAAC,CAAC0J,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;EAChC;EACA,MAAME,MAAM,GAAG,EAAE;EACjB,KAAK,IAAInJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiJ,UAAU,CAAC1J,MAAM,EAAES,CAAC,IAAI,CAAC,EAAE;IAC7C,MAAMoJ,SAAS,GAAGH,UAAU,CAACjJ,CAAC,CAAC;IAC/B,IAAIoJ,SAAS,EAAE;MACb,MAAM,CAACC,IAAI,EAAEC,QAAQ,CAAC,GAAGF,SAAS,CAACvK,KAAK,CAAC,GAAG,CAAC;MAC7C,MAAM0K,SAAS,GAAGD,QAAQ,CAACE,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG;MACxD,MAAM9K,KAAK,GAAG4K,QAAQ,CAACzK,KAAK,CAAC0K,SAAS,CAAC,CAACX,GAAG,CAACa,GAAG,IAAIA,GAAG,CAACP,IAAI,CAAC,CAAC,CAAC;MAC9DC,MAAM,CAAChJ,IAAI,CAAC;QACVuJ,SAAS,EAAEL,IAAI,CAACH,IAAI,CAAC,CAAC;QACtBxK;MACF,CAAC,CAAC;IACJ;EACF;EACA,OAAOyK,MAAM;AACf,CAAC;AACD,MAAMQ,UAAU,GAAGjL,KAAK,IAAI;EAC1B,MAAMkL,WAAW,GAAG,sBAAsB;EAC1C,MAAM,GAAGC,KAAK,EAAEvJ,IAAI,CAAC,GAAGsJ,WAAW,CAACxC,IAAI,CAAC1I,KAAK,CAAC;EAC/C,MAAMoL,MAAM,GAAGC,MAAM,CAAC1C,UAAU,CAACwC,KAAK,CAAC;EACvC,OAAOvJ,IAAI,KAAK,KAAK,GAAGwJ,MAAM,GAAG,GAAG,GAAG9B,IAAI,CAACgC,EAAE,GAAGF,MAAM;AACzD,CAAC;AACD,MAAMG,2BAA2B,GAAGrJ,IAAI,IAAI;EAC1C,IAAI;IACF8I,SAAS;IACThL;EACF,CAAC,GAAGkC,IAAI;EACR,QAAQ8I,SAAS;IACf,KAAK,OAAO;MACV;QACE,MAAM,CAACQ,MAAM,EAAEC,MAAM,GAAGD,MAAM,CAAC,GAAGxL,KAAK,CAACkK,GAAG,CAACwB,GAAG,IAAIL,MAAM,CAAC1C,UAAU,CAAC+C,GAAG,CAAC,CAAC;QAC1E,OAAO;UACLV,SAAS,EAAE,OAAO;UAClBhL,KAAK,EAAE,CAACwL,MAAM,EAAEC,MAAM;QACxB,CAAC;MACH;IACF,KAAK,QAAQ;MACX;QACE,OAAO;UACLT,SAAS,EAAE,OAAO;UAClBhL,KAAK,EAAE,CAACqL,MAAM,CAAC1C,UAAU,CAAC3I,KAAK,CAAC,EAAE,CAAC;QACrC,CAAC;MACH;IACF,KAAK,QAAQ;MACX;QACE,OAAO;UACLgL,SAAS,EAAE,OAAO;UAClBhL,KAAK,EAAE,CAAC,CAAC,EAAEqL,MAAM,CAAC1C,UAAU,CAAC3I,KAAK,CAAC;QACrC,CAAC;MACH;IACF,KAAK,QAAQ;MACX;QACE,OAAO;UACLgL,SAAS,EAAE,QAAQ;UACnBhL,KAAK,EAAE,CAACiL,UAAU,CAACjL,KAAK,CAAC;QAC3B,CAAC;MACH;IACF,KAAK,WAAW;MACd;QACE,OAAO;UACLgL,SAAS,EAAE,WAAW;UACtBhL,KAAK,EAAEA,KAAK,CAACkK,GAAG,CAACwB,GAAG,IAAIL,MAAM,CAAC1C,UAAU,CAAC+C,GAAG,CAAC;QAChD,CAAC;MACH;IACF,KAAK,YAAY;MACf;QACE,OAAO;UACLV,SAAS,EAAE,WAAW;UACtBhL,KAAK,EAAE,CAACqL,MAAM,CAAC1C,UAAU,CAAC3I,KAAK,CAAC,EAAE,CAAC;QACrC,CAAC;MACH;IACF,KAAK,YAAY;MACf;QACE,OAAO;UACLgL,SAAS,EAAE,WAAW;UACtBhL,KAAK,EAAE,CAAC,CAAC,EAAEqL,MAAM,CAAC1C,UAAU,CAAC3I,KAAK,CAAC;QACrC,CAAC;MACH;IACF,KAAK,MAAM;MACT;QACE,OAAO;UACLgL,SAAS,EAAE,MAAM;UACjBhL,KAAK,EAAEA,KAAK,CAACkK,GAAG,CAACe,UAAU;QAC7B,CAAC;MACH;IACF,KAAK,OAAO;MACV;QACE,OAAO;UACLD,SAAS,EAAE,MAAM;UACjBhL,KAAK,EAAE,CAACiL,UAAU,CAACjL,KAAK,CAAC,EAAE,CAAC;QAC9B,CAAC;MACH;IACF,KAAK,OAAO;MACV;QACE,OAAO;UACLgL,SAAS,EAAE,MAAM;UACjBhL,KAAK,EAAE,CAAC,CAAC,EAAEiL,UAAU,CAACjL,KAAK,CAAC;QAC9B,CAAC;MACH;IACF;MACE;QACE,OAAO;UACLgL,SAAS;UACThL,KAAK,EAAEA,KAAK,CAACkK,GAAG,CAACwB,GAAG,IAAIL,MAAM,CAAC1C,UAAU,CAAC+C,GAAG,CAAC;QAChD,CAAC;MACH;EACJ;AACF,CAAC;AACD,MAAMC,SAAS,GAAGC,UAAU,IAAI;EAC9B,OAAOA,UAAU,CAAC1B,GAAG,CAACc,SAAS,IAAIO,2BAA2B,CAACP,SAAS,CAAC,CAAC;AAC5E,CAAC;AACD,MAAMa,gBAAgB,GAAG7L,KAAK,IAAI;EAChC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE,OAAOA,KAAK;EAC3C,OAAO2L,SAAS,CAACtB,KAAK,CAACrK,KAAK,CAAC,CAAC;AAChC,CAAC;AAED,MAAM8L,YAAY,GAAG;EACnBC,IAAI,EAAE,GAAG;EACTC,QAAQ,EAAE,GAAG;EACbC,UAAU,EAAE,GAAG;EACfC,UAAU,EAAE,GAAG;EACfC,KAAK,EAAE,GAAG;EACVC,MAAM,EAAE,GAAG;EACXC,MAAM,EAAE,GAAG;EACXC,QAAQ,EAAE,GAAG;EACbC,QAAQ,EAAE,GAAG;EACbC,IAAI,EAAE,GAAG;EACTC,SAAS,EAAE,GAAG;EACdC,SAAS,EAAE,GAAG;EACdC,KAAK,EAAE,GAAG;EACVC,KAAK,EAAE;AACT,CAAC;AACD,MAAMC,iBAAiB,GAAG7M,KAAK,IAAI;EACjC,IAAI,CAACA,KAAK,EAAE,OAAO8L,YAAY,CAACM,MAAM;EACtC,IAAI,OAAOpM,KAAK,KAAK,QAAQ,EAAE,OAAOA,KAAK;EAC3C,MAAM8M,EAAE,GAAG9M,KAAK,CAAC+M,WAAW,CAAC,CAAC;EAC9B,IAAIjB,YAAY,CAACgB,EAAE,CAAC,EAAE,OAAOhB,YAAY,CAACgB,EAAE,CAAC;EAC7C,OAAO9M,KAAK;AACd,CAAC;;AAED;;AAEA,MAAMgN,iBAAiB,GAAGA,CAAChN,KAAK,EAAEgI,MAAM,KAAK;EAC3C,IAAIhI,KAAK,KAAK,EAAE,EAAE,OAAOA,KAAK;EAC9B,MAAM;IACJiN,QAAQ,GAAG;EACb,CAAC,GAAGjF,MAAM;;EAEV;EACA,MAAM;IACJkF;EACF,CAAC,GAAG5N,YAAY,CAACU,KAAK,CAAC,IAAI,CAAC,CAAC;EAC7B,IAAIkN,OAAO,EAAE,OAAOA,OAAO,GAAGD,QAAQ;;EAEtC;EACA,OAAOE,KAAK,CAACnN,KAAK,CAAC,GAAGA,KAAK,GAAGA,KAAK,GAAGiN,QAAQ;AAChD,CAAC;AAED,MAAMG,WAAW,GAAGpN,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,eAAe,CAACyJ,IAAI,CAACzJ,KAAK,CAAC;AACrF,MAAMqN,SAAS,GAAGrN,KAAK,IAAI;EACzB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE,OAAOA,KAAK;EAC3C,IAAIoN,WAAW,CAACpN,KAAK,CAAC,EAAE,OAAO2I,UAAU,CAAC3I,KAAK,CAAC;EAChD,OAAOA,KAAK;AACd,CAAC;AAED,MAAMsN,aAAa,GAAGtN,KAAK,IAAI;EAC7B,QAAQA,KAAK;IACX,KAAK,KAAK;IACV,KAAK,MAAM;MACT,OAAO,IAAI;IACb,KAAK,OAAO;IACZ,KAAK,QAAQ;MACX,OAAO,MAAM;IACf,KAAK,QAAQ;MACX,OAAO,KAAK;IACd;MACE,OAAO,IAAI;EACf;AACF,CAAC;AAED,MAAMuN,uBAAuB,GAAGvN,KAAK,IAAIsN,aAAa,CAACtN,KAAK,CAAC,IAAIqN,SAAS,CAACrN,KAAK,CAAC;AAEjF,MAAMwN,wBAAwB,GAAGxN,KAAK,IAAIsN,aAAa,CAACtN,KAAK,CAAC,IAAIqN,SAAS,CAACrN,KAAK,CAAC;AAElF,MAAMyN,QAAQ,GAAG;EACf/C,SAAS,EAAEmB,gBAAgB;EAC3B6B,UAAU,EAAEb,iBAAiB;EAC7Bc,UAAU,EAAEX,iBAAiB;EAC7BrI,eAAe,EAAE4I,uBAAuB;EACxC3I,eAAe,EAAE2I,uBAAuB;EACxC/H,gBAAgB,EAAEgI,wBAAwB;EAC1C/H,gBAAgB,EAAE+H;AACpB,CAAC;AACD,MAAMI,cAAc,GAAGA,CAAC7N,GAAG,EAAEC,KAAK,EAAEgI,MAAM,EAAEa,SAAS,KAAK;EACxD,MAAMnH,MAAM,GAAG+L,QAAQ,CAAC1N,GAAG,CAAC,GAAG0N,QAAQ,CAAC1N,GAAG,CAAC,CAACC,KAAK,EAAEgI,MAAM,CAAC,GAAGhI,KAAK;EACnE,OAAOoK,cAAc,CAACxB,aAAa,CAACC,SAAS,EAAEwE,SAAS,CAAC3L,MAAM,CAAC,CAAC,CAAC;AACpE,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMgJ,SAAS,GAAG7B,SAAS,IAAIb,MAAM,IAAI;EACvC,IAAI,CAACA,MAAM,EAAE,OAAOA,MAAM;EAC1B,MAAMb,UAAU,GAAGC,MAAM,CAACC,IAAI,CAACW,MAAM,CAAC;EACtC,MAAMV,aAAa,GAAG,CAAC,CAAC;EACxB,KAAK,IAAIhG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6F,UAAU,CAACtG,MAAM,EAAES,CAAC,IAAI,CAAC,EAAE;IAC7C,MAAMvB,GAAG,GAAGoH,UAAU,CAAC7F,CAAC,CAAC;IACzB,MAAMtB,KAAK,GAAGgI,MAAM,CAACjI,GAAG,CAAC;IACzB,MAAM8N,WAAW,GAAGD,cAAc,CAAC7N,GAAG,EAAEC,KAAK,EAAEgI,MAAM,EAAEa,SAAS,CAAC;IACjEvB,aAAa,CAACvH,GAAG,CAAC,GAAG8N,WAAW;EAClC;EACA,OAAOvG,aAAa;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMwG,mBAAmB,GAAGA,CAACjF,SAAS,EAAEb,MAAM,KAAK;EACjD,OAAOZ,MAAM,CAACC,IAAI,CAACW,MAAM,CAAC,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEnI,GAAG,KAAK;IAC9C,IAAI,QAAQ,CAAC0J,IAAI,CAAC1J,GAAG,CAAC,EAAE;MACtB,OAAO;QACL,GAAGmI,GAAG;QACN,GAAGvI,UAAU,CAAC;UACZ,CAACI,GAAG,GAAGiI,MAAM,CAACjI,GAAG;QACnB,CAAC,EAAE8I,SAAS;MACd,CAAC;IACH;IACA,OAAO;MACL,GAAGX,GAAG;MACN,CAACnI,GAAG,GAAGiI,MAAM,CAACjI,GAAG;IACnB,CAAC;EACH,CAAC,EAAE,CAAC,CAAC,CAAC;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMgO,aAAa,GAAGA,CAAClF,SAAS,EAAEpI,KAAK,KAAK;EAC1C,MAAMuN,mBAAmB,GAAGhO,KAAK,IAAI8N,mBAAmB,CAACjF,SAAS,EAAE7I,KAAK,CAAC;EAC1E,OAAOZ,OAAO,CAACsL,SAAS,CAAC7B,SAAS,CAAC,EAAE3B,MAAM,EAAE8G,mBAAmB,EAAE1F,OAAO,CAAC,CAAC7H,KAAK,CAAC;AACnF,CAAC;AAED,SAASsN,aAAa,IAAIE,OAAO,EAAE3F,OAAO,EAAEuD,gBAAgB,EAAEzB,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}